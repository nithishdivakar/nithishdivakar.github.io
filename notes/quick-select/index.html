<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><title>Quick Select | DAXPY</title><link rel=stylesheet href=/css/main.min.9e0d91ee5e43768adbd3e495fb3273f760195e4e09cae07eb8461013ded5303d.css integrity="sha256-ng2R7l5Ddorb0+SV+zJz92AZXk4JyuB+uEYQE97VMD0=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header><nav><ul><li><a class=text_secondary href=https://daxpy.xyz/>DAXPY</a></li><li>|</li><li><a class=text_secondary href=https://daxpy.xyz/posts/>posts</a></li><li><a class=text_secondary href=https://daxpy.xyz/notes/>notes</a></li><li><a class=text_secondary href=https://daxpy.xyz/links/>links</a></li><li><a class=text_secondary href=https://daxpy.xyz/stories/>stories</a></li><li><a class=text_secondary href=/about>about</a></li></ul></nav></header><main><section><article><h1 id=quick-select>Quick Select</h1><p>The core technique in quick sort is partition procedure. The partition procedure partitions the array into 2 segments such that for a choosen pivot element, one segment has all element smaller or equal and the other has all element larger than pivot.</p><p>The procedure itself has applications beyond quick sort like selecting the smallest $k$ elements if sorted order is not required.</p><p>There are 2 main techniques to implement quick select.</p><h2 id=hoares-method>Hoare&rsquo;s Method</h2><p>Any element can be given as pivot. If we give an element which is not present in the array, the returned index would have the smallest element larger than pivot in the array.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>hoare_partition</span>(A, low, high, pivot):
</span></span><span style=display:flex><span>	left, right <span style=color:#f92672>=</span> low<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, high<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>			left <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> A[left] <span style=color:#f92672>&gt;=</span> pivot: <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>			right <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> A[right] <span style=color:#f92672>&lt;=</span> pivot: <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> left <span style=color:#f92672>&gt;=</span> right:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> right
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		swap(A[left], A[right])
</span></span></code></pre></div><h2 id=lomutos-method>Lomuto&rsquo;s Method</h2><p>The procedure always select the last element in the array as pivot. For choosing any other element in the array as pivot, a preprocessing step which swaps the last element with the choosen pivot is needed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>lomuto_partition</span>(A, low, high):
</span></span><span style=display:flex><span>	pivot <span style=color:#f92672>=</span> A[high]
</span></span><span style=display:flex><span>	p <span style=color:#f92672>=</span> low <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(low,  high): 
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>if</span> A[j] <span style=color:#f92672>&lt;=</span> pivot :
</span></span><span style=display:flex><span>		      p <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		      swap(A[p], A[j]) 
</span></span><span style=display:flex><span>	p <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	swap(A[p], A[high])
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> p 
</span></span></code></pre></div><h2 id=finding-k-smallest-element-in-array>Finding $k$ smallest element in array</h2><p>Also known as quick select, the procedure partially sorts the array.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>quick_select</span>(A, k):
</span></span><span style=display:flex><span>	low, high <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len(A)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>		pivot <span style=color:#f92672>=</span> random_index(low, high)
</span></span><span style=display:flex><span>		index <span style=color:#f92672>=</span> partition(A, low, high, A[pivot])
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> index <span style=color:#f92672>==</span> k:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> A[:k]
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> index <span style=color:#f92672>&lt;</span> k:
</span></span><span style=display:flex><span>			left <span style=color:#f92672>=</span> index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>			right <span style=color:#f92672>=</span> index <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Like quick sort, quick select has average linear time complexity, but quadratic time complexity in worst case.</p></article><br><br><br><i>tags:</i>
<a class=gray style=padding-right:5px href=/tags#algorithms><i>#algorithms</i></a></section></main><footer><p>...</p></footer></body></html>