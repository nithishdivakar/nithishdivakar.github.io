<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><title>Knapsack | DAXPY</title><link rel=stylesheet href=/css/main.min.9e0d91ee5e43768adbd3e495fb3273f760195e4e09cae07eb8461013ded5303d.css integrity="sha256-ng2R7l5Ddorb0+SV+zJz92AZXk4JyuB+uEYQE97VMD0=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header><nav><ul><li><a class=text_secondary href=https://daxpy.xyz/>DAXPY</a></li><li>|</li><li><a class=text_secondary href=https://daxpy.xyz/posts/>posts</a></li><li><a class=text_secondary href=https://daxpy.xyz/notes/>notes</a></li><li><a class=text_secondary href=https://daxpy.xyz/links/>links</a></li><li><a class=text_secondary href=https://daxpy.xyz/stories/>stories</a></li><li><a class=text_secondary href=/about>about</a></li></ul></nav></header><main><section><article><h1 id=knapsack>Knapsack</h1><p>Knapsack problems are probably the first introduction to many on problems where you are trying to optimize a dimension while constrained by another. Let&rsquo;s look at it in depth.</p><p>You are given a metaphorical knapsack which atmost can carry $W$ weight items. You are also given $n$ items, each with its own weight $w_i$ and value $v_i$. We are asked to select a few items from this set so that the total weight is atmost $W$ while maximising the total value.</p><p>If we say $x_i \in \{0,1\}$ represents wether item $i$ is selected or not in a possible solution, then the problem is</p><p>$$\begin{align}
&\max \sum_i x_i v_i
\\
&amp;s.t. \quad \sum_i x_i w_i \leq T
\end{align}$$</p><p>There are 3 broad classifications of knapsack problems:</p><ol><li>Bounded knapsack: We can select an item only once.</li><li>Unbounded knapsack: We have an infinite copies of each item.</li><li>Fractional knapsack: We can select a fraction of any item.</li></ol><p>What if we have at most $c$ copies of each item. This is trivially reducible to Bounded knapsack if we assume they are $c$ distinct items which happen to have same weight and value. This reduction applies to any case where the number of copies of each item is finite. For this reason, Bounded knapsack is also called 0/1 knapsack.</p><h2 id=01-knapsack>0/1 knapsack</h2><p>So we can either select an item or not while maximizing the values.</p><p>The solution is quite easy to describe. Try all possible combinations of items; all $2^n$ of them, and see which one is the best. However, we can do better than enumerating all possible combinations by exploiting the <a href=https://en.wikipedia.org/wiki/Optimal_substructure>optimal substructure</a> of the problem.</p><p>Concretely, the impact of choosing or not choosing item $i$ on the solution can be depicted as</p><p>$S(i,w) = \max \{v_i + S(i-1, w-w_i), S(i-1,w)\}$</p><p>where $S(i,w)$ represents the maximum value that can be achieved with a maximum weight of $w$ using some subset of the first $i$ items.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>knapsack_01</span>(
</span></span><span style=display:flex><span>    weights: List[int], 
</span></span><span style=display:flex><span>    values: List[int], 
</span></span><span style=display:flex><span>    capacity: int
</span></span><span style=display:flex><span>) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    max_value <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span> <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(capacity <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> weight, value <span style=color:#f92672>in</span> zip(weights, values):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> weight <span style=color:#f92672>&gt;</span> capacity:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> slack <span style=color:#f92672>in</span> range(capacity <span style=color:#f92672>-</span> weight, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            max_value[slack <span style=color:#f92672>+</span> weight] <span style=color:#f92672>=</span> max(
</span></span><span style=display:flex><span>                max_value[slack <span style=color:#f92672>+</span> weight], 
</span></span><span style=display:flex><span>                max_value[slack] <span style=color:#f92672>+</span> value
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_value[capacity]
</span></span></code></pre></div><p>This algorithm takes $O(nW)$ time and $O(W)$ space to run. The time complexity is called sublinear as $W$ can be a bit unbounded. <em>W = capacity</em></p><h2 id=unbounded-knapsack>Unbounded knapsack</h2><p>When we have infinite copies of each items, we have <strong>unbounded knapsack</strong> problem. $x_i > 0$ and $x_i\in \mathbb{Z}$. Let talk about this using an example; the coin change problem.</p><h3 id=coin-change>Coin Change</h3><p>Given a set of coins denomination find the smallest collection of coins that add up to a given amount.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>coin_change</span>(coins: List[int], amount: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    min_coins <span style=color:#f92672>=</span> [float(<span style=color:#e6db74>&#39;inf&#39;</span>)] <span style=color:#f92672>*</span> (amount <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    min_coins[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> coin <span style=color:#f92672>in</span> coins:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(coin, amount <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            min_coins[i] <span style=color:#f92672>=</span> min(min_coins[i], min_coins[i <span style=color:#f92672>-</span> coin] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> min_coins[amount] <span style=color:#66d9ef>if</span> min_coins[amount] <span style=color:#f92672>!=</span> float(<span style=color:#e6db74>&#39;inf&#39;</span>) <span style=color:#66d9ef>else</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><h2 id=fractional-knapsack>Fractional Knapsack</h2><p>The fractional knapsack problem allows us to pick and add a fraction of an item. It is easier to solve than the 0/1 knapsack problem. The solution employs a greedy approach, where we continuously add items based on their value-to-weight ratio until the knapsack&rsquo;s capacity is reached.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fractional_knapsack</span>(
</span></span><span style=display:flex><span>    values: List[float], 
</span></span><span style=display:flex><span>    weights: List[float], 
</span></span><span style=display:flex><span>    capacity: float
</span></span><span style=display:flex><span>) <span style=color:#f92672>-&gt;</span> List[float]:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ratio_sorted <span style=color:#f92672>=</span> sorted(
</span></span><span style=display:flex><span>        zip(values, weights), 
</span></span><span style=display:flex><span>        key<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> item: item[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>/</span> item[<span style=color:#ae81ff>1</span>], 
</span></span><span style=display:flex><span>        reverse<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fractions <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0.0</span>] <span style=color:#f92672>*</span> len(values)
</span></span><span style=display:flex><span>    current_weight <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, (value, weight) <span style=color:#f92672>in</span> enumerate(ratio_sorted):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> current_weight <span style=color:#f92672>&gt;=</span> capacity:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        fractions[i] <span style=color:#f92672>=</span> min(
</span></span><span style=display:flex><span>            (capacity <span style=color:#f92672>-</span> current_weight) <span style=color:#f92672>/</span> weight, 
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        current_weight <span style=color:#f92672>+=</span> weight <span style=color:#f92672>*</span> fractions[i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fractions
</span></span></code></pre></div><p>Although the algorithm makes only a single pass, it takes $O(n \log n)$ time due to the sorting at the beginning.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>subset_sum</span>(nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    max_value <span style=color:#f92672>=</span> knapsack_01(nums, nums, target)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_value <span style=color:#f92672>==</span> target
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>knapsack_01</span>(weights: List[int], values: List[int], capacity: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    max_value <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (capacity <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> weight, value <span style=color:#f92672>in</span> zip(weights, values):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> slack <span style=color:#f92672>in</span> range(capacity, weight <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            max_value[slack] <span style=color:#f92672>=</span> max(max_value[slack], max_value[slack <span style=color:#f92672>-</span> weight] <span style=color:#f92672>+</span> value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_value[capacity]
</span></span></code></pre></div></article><br><br><br><i>tags:</i>
<a class=gray style=padding-right:5px href=/tags#algorithms><i>#algorithms</i></a></section></main><footer><p>...</p></footer></body></html>