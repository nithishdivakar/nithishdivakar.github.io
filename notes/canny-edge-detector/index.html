<!doctype html><html style=height:100%><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://daxpy.xyz/favicon.ico><link rel=stylesheet href=/css/style.min.css><link href="//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic" rel=stylesheet type=text/css><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><title>Canny Edge detector</title></head><body style=height:100%><div class=container style=display:flex;flex-direction:column;min-height:100vh><div class=header><header id=banner style=display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:flex-start;align-items:baseline><big class=h2 style="flex: 0 0 80px;"><b><a href=https://daxpy.xyz/ class=black>daxpy</a></b></big><nav style=flex:0px><ul style=display:flex;flex-direction:row;gap:.5rem><li><a href=https://daxpy.xyz/notes/>Notes</a></li><li><a href=https://daxpy.xyz/posts/>Posts</a></li><li><a href=https://daxpy.xyz/links/>Links</a></li><li><a href=https://daxpy.xyz/random/>Random</a></li><li><a href=/about>about</a></li></ul></nav></header><hr style=margin:0></div><div class=main style=flex:1><main id=content><section><h1 id=canny-edge-detector>Canny Edge detector</h1><p>Steps:</p><ul><li>Apply <strong>Gaussian filtering</strong> to smooth out noise in the image</li><li><strong>Compute gradients</strong>: Compute horizontal($G_x$) and vertical gradients ($G_y$). Magnitude and direction of gradients can then be compluted as
$$\begin{aligned}
m &= \sqrt{G_x^2+G_y^2}
&
\theta &= \tan ^{-1}\left(\frac{G_y}{G_x}\right)
\end{aligned}$$
The angle is then rounded off so that $\theta \in {0,45,90,135}$</li><li><strong>Non-maximal suppression</strong>: For each pixel $(m,\theta)$, if its gradient intensity is maximum among the pixels in negative and positive gradient direction, the value is preserved. Otherwise it is suppressed.</li><li><strong>Double thresholding</strong>
$$\begin{aligned}
m \geq t_h &\implies \text{strong edge pixel}
\\
t_l &lt; m &lt; t_h &\implies \text{weak edge pixel}
\\
m \leq t_l &\implies \text{suppress}
\end{aligned}$$</li><li><strong>Edge tracking by hysteresis</strong>: All strong pixels are selected as true edge pixels. All the weak pixels which has a strong pixel in its $8 \times 8$ neighbourhood are also selected as a true edge. All the others are removed.</li></ul><br><br><br><i>tags:</i>
<a class=gray style=padding-right:5px href=/tags#computer-vision>computer-vision</a></section></main></div><div class=footer><br><br><hr style=margin:0><footer id=footer><div>Ping me <a class=green href=https://twitter.com/nithishdivakar>@nithishdivakar</a></div><div><a href=/resources>::</a></div></footer></div></div></body></html>