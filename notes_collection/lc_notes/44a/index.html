<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><title>Find Eventual Safe States | DAXPY</title><link rel=stylesheet href=/css/main.min.09b566cf287e6fb5c0477b301eeb6144854b92718d35549d0fa0f150a67136eb.css integrity="sha256-CbVmzyh+b7XAR3swHuthRIVLknGNNVSdD6DxUKZxNus=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header><nav><ul><li><a class=text_secondary href=https://daxpy.xyz/>DAXPY</a></li><li>|</li><li><a href=https://daxpy.xyz/posts/>Posts</a></li><li><a href=https://daxpy.xyz/notes/>Notes</a></li><li><a href=https://daxpy.xyz/links/>Links</a></li><li><a href=https://daxpy.xyz/stories/>Stories</a></li><li><a href=/about>About</a></li></ul></nav></header><main><section><article><h2 id=find-eventual-safe-states-lc802>Find Eventual Safe States [LC#802]</h2><blockquote><p>There is a directed graph of <code>n</code> nodes with each node labeled from <code>0</code> to <code>n - 1</code>. The graph is represented by a 0-indexed 2D integer array graph where <code>graph[i]</code> is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in <code>graph[i]</code>.</p><p>A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node). Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.</p></blockquote><h3 id=intuition>Intuition</h3><p>Terminal nodes are safe nodes. Any node whose all ougoing edge are to safe nodes are also safe. We can iteratively grow the list of safe nodes this way. Essentially, topological sort on the reverse graph.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>eventual_safe_nodes</span>(graph: List[List[int]]) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(graph)
</span></span><span style=display:flex><span>    in_degree <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    reverse_graph <span style=color:#f92672>=</span> [[] <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n)]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> node <span style=color:#f92672>in</span> graph[i]:
</span></span><span style=display:flex><span>            reverse_graph[node]<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>            in_degree[i] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    safe_nodes <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque([i <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n) <span style=color:#66d9ef>if</span> in_degree[i]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>        safe_nodes<span style=color:#f92672>.</span>append(node)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> neigh <span style=color:#f92672>in</span> reverse_graph[node]:
</span></span><span style=display:flex><span>            in_degree[neigh] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> in_degree[neigh] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append(neigh)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sorted(safe_nodes)
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><p>$T(n) = $ $S(n) = $</p></article><br><br><br><i>tags:</i>
<a class=gray style=padding-right:5px href=/tags#topological%20sort><i>#topological sort</i></a></section></main><footer><p>Found something useful here? pass it on; or tell me about it!<nav><ul><li><a href="https://drive.google.com/drive/folders/18LU6PKnxy8rDrAXhpiPXV2yOYlO_I8cF?usp=sharing">Resume</a></li><li><a href=https://daxpy.xyz/omnia_mea>Coding notes</a></li><li><a href=https://www.linkedin.com/in/ndivakar/>Linkedin</a></li></ul></nav><small><a href=#top>â†‘ Top of page</a></small></p></footer></body></html>