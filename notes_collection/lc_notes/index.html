<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><title>LC Notes | DAXPY</title><link rel=stylesheet href=/css/main.min.09b566cf287e6fb5c0477b301eeb6144854b92718d35549d0fa0f150a67136eb.css integrity="sha256-CbVmzyh+b7XAR3swHuthRIVLknGNNVSdD6DxUKZxNus=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header><nav><ul><li><a class=text_secondary href=https://daxpy.xyz/>DAXPY</a></li><li>|</li><li><a href=https://daxpy.xyz/posts/>Posts</a></li><li><a href=https://daxpy.xyz/notes/>Notes</a></li><li><a href=https://daxpy.xyz/links/>Links</a></li><li><a href=https://daxpy.xyz/stories/>Stories</a></li><li><a href=/about>About</a></li></ul></nav></header><main><h1>Notes Collection: LC</h1><p><b>Table of Content</b></p><ul><li><a href=#01><span style=font-size:larger;color:red>01 Arrays</span></a></li><li><a href=#01a01><span>01a01 Two Sum</span></a></li><li><a href=#01a01a><span>01a01a Three Sum</span></a></li><li><a href=#01a03><span>01a03 Duplicate Number</span></a></li><li><a href=#01a06><span>01a06 Rotate Array</span></a></li><li><a href=#01c><span style=font-size:medium;color:green>01c Sorting</span></a></li><li><a href=#01c01><span>01c01 Quick Sort</span></a></li><li><a href=#02><span style=font-size:larger;color:red>02 Strings</span></a></li><li><a href=#02b><span>02b Longest Common Prefix</span></a></li><li><a href=#02c><span>02c Group Anagrams</span></a></li><li><a href=#02h01><span>02h01 Reorganize String</span></a></li><li><a href=#14><span style=font-size:larger;color:red>14 Subarray</span></a></li><li><a href=#14a><span>14a Maximum Subarray Sum</span></a></li><li><a href=#14b><span>14b Best Time to Buy and Sell Stock</span></a></li><li><a href=#14b01><span>14b01 Best Time to Buy and Sell Stock II</span></a></li><li><a href=#14b02><span>14b02 Best Time to Buy and Sell Stock IV</span></a></li><li><a href=#14c><span>14c Continuous Subarray Sum</span></a></li><li><a href=#14d><span>14d Subarray Sum Equals K</span></a></li><li><a href=#14e><span>14e Product of Array Except Self</span></a></li><li><a href=#14f><span>14f Maximize Subarray Sum After Removing All Occurrences of One Element</span></a></li><li><a href=#16><span style=font-size:larger;color:red>16 Stack</span></a></li><li><a href=#16a><span>16a Asteroid Collision</span></a></li><li><a href=#18><span style=font-size:larger;color:red>18 Linked List</span></a></li><li><a href=#18a><span>18a Reverse Linked List</span></a></li><li><a href=#18b><span>18b Remove Nth Node From End of List</span></a></li><li><a href=#18c><span>18c Merging Two Sorted Linked Lists</span></a></li><li><a href=#18e><span>18e Merge K Sorted Lists</span></a></li><li><a href=#18f><span>18f Detecting a Cycle in Linked List</span></a></li><li><a href=#18g><span>18g Implementing LRU Cache</span></a></li><li><a href=#18h><span>18h Remove Nodes From Linked List</span></a></li><li><a href=#20><span style=font-size:larger;color:red>20 Sequences</span></a></li><li><a href=#20a><span>20a Longest Consecutive Sequence</span></a></li><li><a href=#20b><span style=font-size:medium;color:green>20b Longest Increasing Subsequence</span></a></li><li><a href=#20b01><span>20b01 Russian Doll</span></a></li><li><a href=#20c><span>20c Longest Common Subsequence</span></a></li><li><a href=#20d><span>20d Longest Palindromic Subsequence</span></a></li><li><a href=#20e><span>20e Sum of Good Subsequences</span></a></li><li><a href=#22><span style=font-size:larger;color:red>22 Palindromes</span></a></li><li><a href=#22a><span>22a Longest Palindromic Substring</span></a></li><li><a href=#22b><span>22b Count Palindromic Substrings</span></a></li><li><a href=#22c><span>22c Manacher Algorithm</span></a></li><li><a href=#22d><span>22d Palindromic Partition</span></a></li><li><a href=#23><span style=font-size:larger;color:red>23 Parentheses</span></a></li><li><a href=#23a><span>23a Longest Valid Parentheses</span></a></li><li><a href=#23b><span>23b Valid Parenthesis String</span></a></li><li><a href=#23c><span>23c Minimum Add to Make Parentheses Valid</span></a></li><li><a href=#25><span style=font-size:larger;color:red>25 Two Pointers</span></a></li><li><a href=#25a><span>25a Containers with Most Water</span></a></li><li><a href=#27><span style=font-size:larger;color:red>27 Sliding Window</span></a></li><li><a href=#27a><span>27a Longest Substring Without Repeating Characters</span></a></li><li><a href=#27b><span>27b String Compression</span></a></li><li><a href=#27c><span>27c Take K of Each Character From Left and Right</span></a></li><li><a href=#27d><span>27d Partition Labels</span></a></li><li><a href=#30><span style=font-size:larger;color:red>30 Trees</span></a></li><li><a href=#30a><span>30a Tree Traversals</span></a></li><li><a href=#30a01><span>30a01 In Order</span></a></li><li><a href=#30a02><span>30a02 Pre Order</span></a></li><li><a href=#30a03><span>30a03 Post Order</span></a></li><li><a href=#30a04><span>30a04 Level Order</span></a></li><li><a href=#30a05><span>30a05 Binary Tree from its Traversals</span></a></li><li><a href=#30b><span>30b Binary Tree Maximum Path Sum</span></a></li><li><a href=#30c><span>30c Lowest Common Ancestor</span></a></li><li><a href=#30c01><span>30c01 In a Binary Tree</span></a></li><li><a href=#30c02><span>30c02 In a Binary Search Tree</span></a></li><li><a href=#30d><span>30d Segment Trees</span></a></li><li><a href=#30e01><span>30e01 Check Completeness of a Binary Tree</span></a></li><li><a href=#32><span style=font-size:larger;color:red>32 Heap</span></a></li><li><a href=#32a><span>32a Median in a Stream</span></a></li><li><a href=#35><span style=font-size:larger;color:red>35 BFS</span></a></li><li><a href=#35a><span>35a Shortest Path in Binary Matrix</span></a></li><li><a href=#35b><span>35b 01 Matrix</span></a></li><li><a href=#35c><span>35c All Nodes Distance K in Binary Tree</span></a></li><li><a href=#37><span style=font-size:larger;color:red>37 DFS</span></a></li><li><a href=#37c><span>37c Reconstruct Itinerary</span></a></li><li><a href=#40><span style=font-size:larger;color:red>40 Single Source Shortest Path</span></a></li><li><a href=#40a><span>40a Dijkstra Algorithm</span></a></li><li><a href=#40a01><span>40a01 Cheapest Flights Within K Stops</span></a></li><li><a href=#40b><span>40b Bellman-Ford Algorithm</span></a></li><li><a href=#42><span style=font-size:larger;color:red>42 Minimum Spanning Tree</span></a></li><li><a href=#42a><span>42a Kruskals algorithm</span></a></li><li><a href=#42a01><span>42a01 Min Cost to Connect All Points</span></a></li><li><a href=#42b><span>42b Prims Algorithm</span></a></li><li><a href=#44><span style=font-size:larger;color:red>44 Topological Sort</span></a></li><li><a href=#44a><span>44a Find Eventual Safe States</span></a></li><li><a href=#46><span style=font-size:larger;color:red>46 Max Flow Min Cut</span></a></li><li><a href=#50><span style=font-size:larger;color:red>50 Intervals</span></a></li><li><a href=#50a><span>50a Merge Intervals</span></a></li><li><a href=#50b><span>50b Insert Interval</span></a></li><li><a href=#50c><span>50c Min Meeting Rooms</span></a></li><li><a href=#50d><span style=font-size:medium;color:green>50d Line Sweep Technique</span></a></li><li><a href=#50d01><span>50d01 Zero Array Transformation I</span></a></li><li><a href=#50d02><span>50d02 Zero Array Transformation II</span></a></li><li><a href=#50d03><span>50d03 Smallest Range Covering Elements from K Lists</span></a></li><li><a href=#50e><span>50e Minimum Number of Arrows to Burst Balloons</span></a></li><li><a href=#60><span style=font-size:larger;color:red>60 Monotonic Stack</span></a></li><li><a href=#60a><span>60a Largest Rectangle in Histogram</span></a></li><li><a href=#60b><span>60b Sum of Subarray Minimums</span></a></li><li><a href=#60c><span>60c Daily Temperatures</span></a></li><li><a href=#65><span style=font-size:larger;color:red>65 Tries</span></a></li><li><a href=#65a><span>65a Word break</span></a></li><li><a href=#70><span style=font-size:larger;color:red>70 Permutations</span></a></li><li><a href=#70a><span>70a Next Permutation</span></a></li><li><a href=#70b><span>70b Permutation Sequence</span></a></li><li><a href=#72><span style=font-size:larger;color:red>72 Sets</span></a></li><li><a href=#72a><span>72a Constructing Powersets</span></a></li><li><a href=#72c><span>72c DSU with Rollbacks</span></a></li><li><a href=#73><span style=font-size:larger;color:red>73 DSU Union-Find</span></a></li><li><a href=#73a><span>73a Number of Connected Components in an Undirected Graph</span></a></li><li><a href=#73b><span>73b The Earliest Moment When Everyone Become Friends</span></a></li><li><a href=#73c><span>73c Making A Large Island</span></a></li><li><a href=#75><span style=font-size:larger;color:red>75 Binary Search</span></a></li><li><a href=#75a><span style=font-size:medium;color:green>75a Binary Search in Array</span></a></li><li><a href=#75a01><span>75a01 Binary Search in Sorted Array</span></a></li><li><a href=#75a02><span>75a02 First and Last Position in a Sorted Array</span></a></li><li><a href=#75a03><span>75a03 Find Minimum in Rotated Sorted Array</span></a></li><li><a href=#75a04><span>75a04 Find Peak Element</span></a></li><li><a href=#75b><span>75b Minimum Limit of Balls in a Bag</span></a></li><li><a href=#75d><span>75d Split Array Largest Sum</span></a></li><li><a href=#75e><span>75e Swim in Rising Water</span></a></li><li><a href=#80><span style=font-size:larger;color:red>80 Dynamic Programming</span></a></li><li><a href=#80a><span>80a Target Sum</span></a></li><li><a href=#80b><span>80b Edit Distances</span></a></li><li><a href=#80c><span>80c Interleaving String</span></a></li><li><a href=#80d><span>80d Distinct Subsequences</span></a></li><li><a href=#84><span style=font-size:larger;color:red>84 Greedy Approach</span></a></li><li><a href=#84a01><span>84a01 Gas Station</span></a></li><li><a href=#84a02><span>84a02 Max Chunks To Make Sorted</span></a></li><li><a href=#84a03><span>84a03 Jump Game</span></a></li><li><a href=#84a03a><span>84a03a Jump Game II</span></a></li><li><a href=#84a03b><span>84a03b Jump Game III</span></a></li><li><a href=#84a04><span>84a04 Maximum Swap</span></a></li><li><a href=#85><span style=font-size:larger;color:red>85 Backtracking</span></a></li><li><a href=#85a><span>85a N-Queens Problem</span></a></li><li><a href=#85b><span>85b Sudoku Solver</span></a></li><li><a href=#87><span style=font-size:larger;color:red>87 Knapsack</span></a></li><li><a href=#87a><span>87a Bounded Knapsack</span></a></li><li><a href=#87b><span>87b Unbounded Knapsack</span></a></li><li><a href=#87c><span>87c Fractional Knapsack</span></a></li><li><a href=#87d><span>87d Subsetsum to knapsack</span></a></li><li><a href=#87e><span style=font-size:medium;color:green>87e Coin Change</span></a></li><li><a href=#87e01><span>87e01 Coin Change</span></a></li><li><a href=#87e02><span>87e02 Coin Change II</span></a></li><li><a href=#90><span style=font-size:larger;color:red>90 Range Queries</span></a></li><li><a href=#90a><span>90a Fenwick Trees and Prefix Sums</span></a></li><li><a href=#90b><span>90b Segment Trees</span></a></li><li><a href=#90c01><span>90c01 Range Frequency Queries</span></a></li><li><a href=#99><span>99 KMP</span></a></li><li><a href=#99a01><span>99a01 Rotate Image</span></a></li><li><a href=#99a02><span>99a02 Count the Number of Fair Pairs</span></a></li></ul><hr><div class=note id=01><div style=text-align:right;height:5px><a name=01 href=/notes_collection/lc_notes/01/ class="xxs grey monospace">01</a></div><h1 id=arrays>Arrays</h1></div><div class=note id=01a01><div style=text-align:right;height:5px><a name=01a01 href=/notes_collection/lc_notes/01a01/ class="xxs grey monospace">01a01</a></div><h2 id=two-sum-lc1>Two sum [LC#1]</h2><blockquote><p>Given an array of integers <code>nums</code> and an <code>integer</code> target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.</p></blockquote><h3 id=sorting-and-two-pointers>Sorting and two pointers</h3><ul><li>$T(n) = O(n \log n)$; $S(n) = O(n)$ for maintaining the index.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>two_sum</span>(nums: List[int], target:Int) <span style=color:#f92672>-&gt;</span> Tuple[int, int]:
</span></span><span style=display:flex><span>    indexed_nums  <span style=color:#f92672>=</span> sorted((n, i) <span style=color:#66d9ef>for</span> i, n <span style=color:#f92672>in</span> enumerate(nums))
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len(indexed_nums) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>        current_sum <span style=color:#f92672>=</span> indexed_nums[left][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> indexed_nums[right][<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> current_sum <span style=color:#f92672>==</span> target:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> (indexed_nums[left][<span style=color:#ae81ff>1</span>], indexed_nums[right][<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> current_sum <span style=color:#f92672>&lt;</span> target:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            right <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><h3 id=hashset>Hashset</h3><ul><li>$T(n) = O(n)$; $S(n) = O(n)$</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>two_sum</span>(nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> Tuple[int, int]:
</span></span><span style=display:flex><span>    num_to_idx <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, num <span style=color:#f92672>in</span> enumerate(nums):
</span></span><span style=display:flex><span>        residue <span style=color:#f92672>=</span> target <span style=color:#f92672>-</span> num
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> residue <span style=color:#f92672>in</span> lut:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> (i, num_to_idx[residue])
</span></span><span style=display:flex><span>        num_to_idx[num] <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span></code></pre></div></div><div class=note id=01a01a><div style=text-align:right;height:5px><a name=01a01a href=/notes_collection/lc_notes/01a01a/ class="xxs grey monospace">01a01a</a></div><h2 id=three-sum-lc15>Three Sum [LC#15]</h2><blockquote><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j, i != k, and j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>. Notice that the solution set must not contain duplicate triplets.</p></blockquote></div><div class=note id=01a03><div style=text-align:right;height:5px><a name=01a03 href=/notes_collection/lc_notes/01a03/ class="xxs grey monospace">01a03</a></div><h2 id=duplicate-number-lc287>Duplicate Number [LC#287]</h2><blockquote><p>Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space.</p></blockquote></div><div class=note id=01a06><div style=text-align:right;height:5px><a name=01a06 href=/notes_collection/lc_notes/01a06/ class="xxs grey monospace">01a06</a></div><h2 id=rotate-array-lc189>Rotate Array [LC#189]</h2><blockquote><p>Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>If we look at the indices formed by k hops, they form a cycle ending at the start indices. If <code>n%k = 0</code> , then there are <code>k</code> such cycles.</li><li>We use 1 extra storage and simply swap the elemnts to their right position.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rotate_array</span>(nums: List[int], k: int) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>    k <span style=color:#f92672>=</span> k <span style=color:#f92672>%</span> n <span style=color:#75715e># for k &gt; n</span>
</span></span><span style=display:flex><span>    start <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> count <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> start
</span></span><span style=display:flex><span>        storage <span style=color:#f92672>=</span> nums[curr]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>            curr <span style=color:#f92672>=</span> (curr <span style=color:#f92672>+</span> k) <span style=color:#f92672>%</span> n
</span></span><span style=display:flex><span>            nums[curr], storage <span style=color:#f92672>=</span> storage, nums[curr]
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> start <span style=color:#f92672>==</span> curr:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        start <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$</li></ul></div><div class=note id=01c><div style=text-align:right;height:5px><a name=01c href=/notes_collection/lc_notes/01c/ class="xxs grey monospace">01c</a></div><h1 id=sorting>Sorting</h1></div><div class=note id=01c01><div style=text-align:right;height:5px><a name=01c01 href=/notes_collection/lc_notes/01c01/ class="xxs grey monospace">01c01</a></div><h2 id=quick-select>Quick Select</h2><h3 id=partition-scheme-intuition>Partition Scheme intuition.</h3><ul><li>Select the last element in the array as pivot.</li><li>Maintain 2 pointer, <code>left</code> and <code>right</code>.</li><li>Traverse the array updating both pointers such that the values in <code>[left, right]</code> is always <code>></code> the pivot.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#  [ ≤ ][ ≤ ][ &gt; ][ &gt; ][ &gt; ][ &gt; ][ ? ][ hi ]     </span>
</span></span><span style=display:flex><span><span style=color:#75715e>#              └─ left        └─ right </span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>lomuto_partition</span>(A, lo, hi):
</span></span><span style=display:flex><span>    pivot <span style=color:#f92672>=</span> A[hi]
</span></span><span style=display:flex><span>    left <span style=color:#f92672>=</span> lo
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> right <span style=color:#f92672>in</span> range(lo,  hi): 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> A[right] <span style=color:#f92672>&lt;=</span> pivot:
</span></span><span style=display:flex><span>            A[left], A[right] <span style=color:#f92672>=</span> A[right], A[left]
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    A[left], A[hi] <span style=color:#f92672>=</span> A[hi], A[left]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> left
</span></span></code></pre></div><h3 id=quick-sort-using-the-partition-scheme>Quick sort using the partition scheme</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>quicksort</span>(A, lo, hi):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> lo <span style=color:#f92672>&gt;=</span>hi <span style=color:#f92672>or</span> lo <span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> lomuto_partition(A, lo, hi)
</span></span><span style=display:flex><span>    quicksort(A, lo, p <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    quicksort(A, p <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, hi)
</span></span></code></pre></div></div><div class=note id=02><div style=text-align:right;height:5px><a name=02 href=/notes_collection/lc_notes/02/ class="xxs grey monospace">02</a></div><h1 id=strings>Strings</h1></div><div class=note id=02b><div style=text-align:right;height:5px><a name=02b href=/notes_collection/lc_notes/02b/ class="xxs grey monospace">02b</a></div><h2 id=longest-common-prefix>Longest Common Prefix</h2></div><div class=note id=02c><div style=text-align:right;height:5px><a name=02c href=/notes_collection/lc_notes/02c/ class="xxs grey monospace">02c</a></div><h2 id=group-anagrams>Group Anagrams</h2></div><div class=note id=02h01><div style=text-align:right;height:5px><a name=02h01 href=/notes_collection/lc_notes/02h01/ class="xxs grey monospace">02h01</a></div><h2 id=reorganize-string-lc767>Reorganize String [LC#767]</h2><blockquote><p>Given a string <code>s</code>, rearrange the characters of s so that any two adjacent characters are not the same. Return any possible rearrangement of s or return "" if not possible.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>If the character with largest frequency appears more that <code>(n+1)//2</code> times, then such an arrangement is not possible.</li><li>Simply arrange max frequent character in interleaved indexes and fill out other characters in the gaps.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>reorganize_string</span>(self, s: str) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>    character_counts <span style=color:#f92672>=</span> Counter(s)
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(s)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> max(character_counts<span style=color:#f92672>.</span>values()) <span style=color:#f92672>&gt;</span> (n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>interleaved_index_generator</span>(n):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, n, <span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>yield</span> i
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n, <span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>yield</span> i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    characters <span style=color:#f92672>=</span> list(s)
</span></span><span style=display:flex><span>    characters<span style=color:#f92672>.</span>sort(
</span></span><span style=display:flex><span>        key<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> char: (character_counts[char], char), 
</span></span><span style=display:flex><span>        <span style=color:#75715e># break tie when 2 chars have same counts</span>
</span></span><span style=display:flex><span>        reverse<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    output <span style=color:#f92672>=</span> characters<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>    interleaved_index <span style=color:#f92672>=</span> interleaved_index_generator(n)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> character <span style=color:#f92672>in</span> characters:
</span></span><span style=display:flex><span>        output[next(interleaved_index)] <span style=color:#f92672>=</span> character
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(output)
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n \log n)$ $S(n) = O(n)$. Time complexity is $O(n)$ if we sort while exploiting the fact that there are only constant number of characters.</li></ul><span class=tag>string</span></div><div class=note id=14><div style=text-align:right;height:5px><a name=14 href=/notes_collection/lc_notes/14/ class="xxs grey monospace">14</a></div><h1 id=subarray>Subarray</h1></div><div class=note id=14a><div style=text-align:right;height:5px><a name=14a href=/notes_collection/lc_notes/14a/ class="xxs grey monospace">14a</a></div><h2 id=maximum-subarray-sum-lc53>Maximum Subarray Sum [LC#53]</h2><blockquote><p>Given an integer array <code>nums</code>, find the subarray with the largest sum, and return its sum.</p></blockquote><p><strong>Kadane&rsquo;s algorithm</strong></p><ul><li>Find the max sum of subarray ending at location <code>i</code>.</li><li>$T(n) = O(n)$; $S(n) = O(1)$</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>max_subarray_sum</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    curr, ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, nums[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> max(curr <span style=color:#f92672>+</span> num, num)
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> max(ans, curr)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans
</span></span></code></pre></div></div><div class=note id=14b><div style=text-align:right;height:5px><a name=14b href=/notes_collection/lc_notes/14b/ class="xxs grey monospace">14b</a></div><h2 id=best-time-to-buy-and-sell-stock-lc121>Best Time to Buy and Sell Stock [LC#121]</h2><blockquote><p>You are given an array prices where <code>prices[i]</code> is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</p></blockquote><h3 id=inutition>Inutition</h3><ul><li>The solution is a variation of Kadane&rsquo;s algorithm.</li><li>Keep track of minimum seen so far.</li><li>Max profit if we sell now can be computed with this minimum.</li><li>Keep track of max profit.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>max_profit</span>(prices: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    max_profit <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    min_price <span style=color:#f92672>=</span> prices[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> price <span style=color:#f92672>in</span> prices:
</span></span><span style=display:flex><span>        min_price <span style=color:#f92672>=</span> min(min_price, price)
</span></span><span style=display:flex><span>        max_profit <span style=color:#f92672>=</span> max(max_profit, price <span style=color:#f92672>-</span> min_price)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_profit
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n)$ and $S(n) = O(1)$</li></ul><span class=tag>greedy</span></div><div class=note id=14b01><div style=text-align:right;height:5px><a name=14b01 href=/notes_collection/lc_notes/14b01/ class="xxs grey monospace">14b01</a></div><h2 id=best-time-to-buy-and-sell-stock-ii-lc122>Best Time to Buy and Sell Stock II [LC#122]</h2><blockquote><p>You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Every climb is the sub profit. Add all sub profits.</li><li><code>[1,7,5,8]</code>. <code>(7-1) + (8-5) > (8 - 1)</code>.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>max_profit</span>(self, prices: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    profit <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, len(prices)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> prices[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;</span> prices[i]:
</span></span><span style=display:flex><span>            profit <span style=color:#f92672>+=</span> (prices[i] <span style=color:#f92672>-</span> prices[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> profit
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$</li></ul><span class=tag>greedy</span></div><div class=note id=14b02><div style=text-align:right;height:5px><a name=14b02 href=/notes_collection/lc_notes/14b02/ class="xxs grey monospace">14b02</a></div><h2 id=best-time-to-buy-and-sell-stock-iv-lc188>Best Time to Buy and Sell Stock IV [LC#188]</h2><blockquote><p>You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p></blockquote><h3 id=intuition>Intuition</h3><ul><li><code>f[k][i]</code> denotes maximum profit obtainable by doing k transactions with first i prices.</li><li>The dp equation is<pre tabindex=0><code>f[k][i] = max(
    f[k][i-1], 
    max( prices[i] - prices[j] + f[k-1, j] for i in [0, i-1] )
)
= max(
    f[k][i-1], 
    prices[i] + max( f[k-1, j] - prices[j] +  for i in [0, i-1] )
)
</code></pre></li><li>Also, <code>f[k][0] = 0</code> and <code>f[0][i] = 0</code></li><li>The inner max can be maintained as a running maximum.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>max_profit_with_k_transactions</span>(K: int, prices: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(prices)
</span></span><span style=display:flex><span>    f <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (n) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(K <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>    max_profit <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, K <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        t <span style=color:#f92672>=</span> f[k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> prices[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n):
</span></span><span style=display:flex><span>            t <span style=color:#f92672>=</span> max(t, f[k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][i] <span style=color:#f92672>-</span> prices[i])
</span></span><span style=display:flex><span>            f[k][i] <span style=color:#f92672>=</span> max(f[k][i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>], prices[i] <span style=color:#f92672>+</span> t)
</span></span><span style=display:flex><span>            max_profit <span style=color:#f92672>=</span> max(max_profit, f[k][i])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_profit
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(nk)$</li><li>$S(n) = O(n)$ Currently $O(nk)$ but can be optimised to use only two array of storage. The algorithm can also be modified to use only $O(k)$ storage.</li></ul></div><div class=note id=14c><div style=text-align:right;height:5px><a name=14c href=/notes_collection/lc_notes/14c/ class="xxs grey monospace">14c</a></div><h2 id=continuous-subarray-sum-lc523>Continuous Subarray Sum [LC#523]</h2><blockquote><p>Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise. A good subarray is a subarray where:</p><ul><li>Its length is at least two, and</li><li>The sum of the elements of the subarray is a multiple of k.</li></ul></blockquote><h3 id=intuition>Intuition</h3><ul><li>For quickly finding sum of a subarray, we can use prefix sums.<ul><li><code>sum(i:j) = prefix(i) - prefix(j)</code></li></ul></li><li>mod operator preoperty:<ul><li><code>(a-b)%k = (a%k - b%k)%k = a%k - b%k</code></li></ul></li><li>So if <code>prefix(i)%k == prefix(j)%k</code> for any <code>i</code> and <code>j</code> more than 2 indices apart, the answer is true.</li><li>Only corner case is a prefix array sum itself that <code>sum%k</code> to 0.</li></ul><h3 id=solution>Solution</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>check_subarray_sum</span>(nums: List[int], k: int) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>    mod_seen <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>}  <span style=color:#75715e># for prefixes that exactly sum%k to 0</span>
</span></span><span style=display:flex><span>    prefix_sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        prefix_sum <span style=color:#f92672>=</span> prefix_sum <span style=color:#f92672>+</span> nums[i]
</span></span><span style=display:flex><span>        prefix_mod <span style=color:#f92672>=</span> prefix_sum <span style=color:#f92672>%</span> k
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> prefix_mod <span style=color:#f92672>in</span> mod_seen:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> i <span style=color:#f92672>-</span> mod_seen[prefix_mod] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            mod_seen[prefix_mod] <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        prefix_sum <span style=color:#f92672>=</span> prefix_mod
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n)$ and $S(n) = O(n)$</li></ul></div><div class=note id=14d><div style=text-align:right;height:5px><a name=14d href=/notes_collection/lc_notes/14d/ class="xxs grey monospace">14d</a></div><h2 id=subarray-sum-equals-k-lc560>Subarray Sum Equals K [LC#560]</h2><blockquote><p>Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k. A subarray is a contiguous non-empty sequence of elements within an array.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>For quickly finiding sum of a subarray, we can use prefix sums.<ul><li><code>sum(i:j) = prefix(i) - prefix(j)</code></li></ul></li><li>While we are computing prefix(i) if <code>residue = prefix(i) - k</code> is already among prefixes, then there is a subarray with sum k. We simply have to keep a count.</li></ul><h3 id=solution>Solution</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_subarray_sum_to_targets</span>(nums: List[int], k: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    prefixes <span style=color:#f92672>=</span> defaultdict(int)
</span></span><span style=display:flex><span>    prefixes[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># empty array is a subarray of sum 0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    current <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    counts <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>        current <span style=color:#f92672>+=</span> num
</span></span><span style=display:flex><span>        counts <span style=color:#f92672>+=</span> prefixes[current <span style=color:#f92672>-</span> k]
</span></span><span style=display:flex><span>        prefixes[current] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> counts
</span></span></code></pre></div><h2 id=time-complexity>Time Complexity</h2><ul><li>$T(n) = O(n)$ and $S(n) = O(n)$</li></ul></div><div class=note id=14e><div style=text-align:right;height:5px><a name=14e href=/notes_collection/lc_notes/14e/ class="xxs grey monospace">14e</a></div><h2 id=product-of-array-except-self-lc238>Product of Array Except Self [LC#238]</h2><blockquote><p>Given an integer array nums, return an array answer such that <code>answer[i]</code> is equal to the product of all the elements of nums except <code>nums[i]</code>. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation.</p></blockquote><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>product_except</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        ans<span style=color:#f92672>.</span>append(ans[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> nums[i])
</span></span><span style=display:flex><span>    post <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        post <span style=color:#f92672>=</span> post <span style=color:#f92672>*</span> nums[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        ans[i] <span style=color:#f92672>=</span> ans[i] <span style=color:#f92672>*</span> post
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n)= O(n)$ and $S(n)= O(n)$</li></ul></div><div class=note id=14f><div style=text-align:right;height:5px><a name=14f href=/notes_collection/lc_notes/14f/ class="xxs grey monospace">14f</a></div><h2 id=maximize-subarray-sum-after-removing-all-occurrences-of-one-element-lc3410>Maximize Subarray Sum After Removing All Occurrences of One Element [LC#3410]</h2><blockquote><p>You are given an integer array nums. You can do the following operation on the array at most once:</p><ul><li>Choose any integer x such that nums remains non-empty on removing all occurrences of x.</li><li>Remove all occurrences of x from the array.</li></ul></blockquote><p>Return the maximum subarray sum across all possible resulting arrays.</p><h3 id=intuition>Intuition</h3><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = $</li><li>$S(n) = $</li></ul></div><div class=note id=16><div style=text-align:right;height:5px><a name=16 href=/notes_collection/lc_notes/16/ class="xxs grey monospace">16</a></div><h1 id=stack>Stack</h1></div><div class=note id=16a><div style=text-align:right;height:5px><a name=16a href=/notes_collection/lc_notes/16a/ class="xxs grey monospace">16a</a></div><h2 id=asteroid-collision-lc735>Asteroid Collision [LC#735]</h2><blockquote><p>We are given an array asteroids of integers representing asteroids in a row. The indices of the asteriod in the array represent their relative position in space. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.</p><p>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.</p></blockquote><h3 id=intuition>Intuition</h3><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>asteroid_collision</span>(asteroids: List[int]) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> asteroid <span style=color:#f92672>in</span> asteroids:
</span></span><span style=display:flex><span>        store <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> asteroid <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># there is collision</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> abs(stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) <span style=color:#f92672>&lt;</span> abs(asteroid):
</span></span><span style=display:flex><span>                stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>                
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>elif</span> abs(stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) <span style=color:#f92672>==</span> abs(asteroid):
</span></span><span style=display:flex><span>                stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>                store <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                store <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> store:
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>.</span>append(asteroid)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> stack
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(n)$</li></ul><span class=tag>stack</span></div><div class=note id=18><div style=text-align:right;height:5px><a name=18 href=/notes_collection/lc_notes/18/ class="xxs grey monospace">18</a></div><h1 id=linked-list>Linked List</h1></div><div class=note id=18a><div style=text-align:right;height:5px><a name=18a href=/notes_collection/lc_notes/18a/ class="xxs grey monospace">18a</a></div><h2 id=reverse-linked-list-lc206>Reverse Linked List [LC#206]</h2><blockquote><p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p></blockquote><h3 id=iterative-approach>Iterative approach</h3><pre tabindex=0><code>     ┌────┐    ┌────┐    ┌────┐
 &lt;-- │prev│    │curr│--&gt; │next│--&gt;
     └────┘    └────┘    └────┘
     ┌────┐    ┌────┐    ┌────┐
 &lt;-- │prev│ &lt;--│curr│    │next│--&gt;
     └────┘    └────┘    └────┘
     ┌────┐    ┌────┐    ┌────┐
 &lt;-- │    │ &lt;--│prev│    │next│--&gt;
     └────┘    └────┘    └────┘
     ┌────┐    ┌────┐    ┌────┐
 &lt;-- │    │ &lt;--│prev│    |curr│--&gt;
     └────┘    └────┘    └────┘
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fn</span>(head):
</span></span><span style=display:flex><span>    curr <span style=color:#f92672>=</span> head
</span></span><span style=display:flex><span>    prev <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> curr:
</span></span><span style=display:flex><span>        next_node <span style=color:#f92672>=</span> curr<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>        curr<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> prev
</span></span><span style=display:flex><span>        prev <span style=color:#f92672>=</span> curr
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> next_node
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> prev
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$</li></ul><span class=tag>linked list</span></div><div class=note id=18b><div style=text-align:right;height:5px><a name=18b href=/notes_collection/lc_notes/18b/ class="xxs grey monospace">18b</a></div><h2 id=remove-nth-node-from-end-of-list-lc19>Remove Nth Node From End of List [LC#19]</h2><blockquote><p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p></blockquote><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>remove_nth_from_end</span>(head: Optional[ListNode], n: int) <span style=color:#f92672>-&gt;</span> Optional[ListNode]:
</span></span><span style=display:flex><span>    fake_head <span style=color:#f92672>=</span> ListNode(<span style=color:#ae81ff>0</span>, head)
</span></span><span style=display:flex><span>    P <span style=color:#f92672>=</span> fake_head
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> n<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> P:
</span></span><span style=display:flex><span>        P <span style=color:#f92672>=</span> P<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>        n<span style=color:#f92672>=</span>n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> P: <span style=color:#66d9ef>return</span> head <span style=color:#75715e># less than n nodes</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Q <span style=color:#f92672>=</span> fake_head
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> P<span style=color:#f92672>.</span>next:
</span></span><span style=display:flex><span>        P <span style=color:#f92672>=</span> P<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>        Q <span style=color:#f92672>=</span> Q<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>    Q<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> Q<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fake_head<span style=color:#f92672>.</span>next
</span></span></code></pre></div><span class=tag>linked list</span></div><div class=note id=18c><div style=text-align:right;height:5px><a name=18c href=/notes_collection/lc_notes/18c/ class="xxs grey monospace">18c</a></div><h2 id=merge-two-sorted-lists-lc21>Merge Two Sorted Lists [LC#21]</h2><p>You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Definition for singly-linked list.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ListNode</span>:
</span></span><span style=display:flex><span>    val: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    next: Optional[ListNode] <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span></code></pre></div><p><strong>Iterate and Merge</strong></p><ul><li>$T(n) = O(m+n)$; $S(n) = O(1)$</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>merge_two_sorted_lists</span>(list1: Optional[ListNode], list2: Optional[ListNode]) <span style=color:#f92672>-&gt;</span> Optional[ListNode]:
</span></span><span style=display:flex><span>      fake_head <span style=color:#f92672>=</span> ListNode()
</span></span><span style=display:flex><span>      current <span style=color:#f92672>=</span> fake_head
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span> list1 <span style=color:#f92672>and</span> list2:
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> list1<span style=color:#f92672>.</span>val <span style=color:#f92672>&lt;</span> list2<span style=color:#f92672>.</span>val:
</span></span><span style=display:flex><span>              current<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> list1
</span></span><span style=display:flex><span>              list1 <span style=color:#f92672>=</span> list1<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>              current<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> list2
</span></span><span style=display:flex><span>              list2 <span style=color:#f92672>=</span> list2<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>          current <span style=color:#f92672>=</span> current<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>      current<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> list1 <span style=color:#66d9ef>if</span> list1 <span style=color:#66d9ef>else</span> list2
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> fake_head<span style=color:#f92672>.</span>next
</span></span></code></pre></div><span class=tag>linked list</span></div><div class=note id=18e><div style=text-align:right;height:5px><a name=18e href=/notes_collection/lc_notes/18e/ class="xxs grey monospace">18e</a></div><h2 id=merge-k-sorted-lists-lc23>Merge k Sorted Lists [LC#23]</h2><blockquote><p>You are given an array of <code>k</code> linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.</p></blockquote><p><strong>Brute-Force</strong></p><ul><li>Merge all lists into one and sort the list</li><li>$T(n) = O(n \log n)$ ; $S(n) = O(n)$</li></ul><p><strong>Priority Queue or Min Heap</strong></p><ul><li>Create a min heap with first values of all the lists</li><li>Repeatedly pop the root of min heap, add to the answer and push the next value of the list where root was from to the heap</li><li>$T(n) = O(k + n \log k)$ heapify + n pop root</li><li>$S(n) = O(k)$ for the heap</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>merge_sorted_lists</span>(lists: List[Optional[ListNode]]) <span style=color:#f92672>-&gt;</span> Optional[ListNode]:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HeapNode</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, node: ListNode):
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>node <span style=color:#f92672>=</span> node
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__lt__</span>(self, other):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>node<span style=color:#f92672>.</span>val <span style=color:#f92672>&lt;</span> other<span style=color:#f92672>.</span>node<span style=color:#f92672>.</span>val
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    heap <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    current <span style=color:#f92672>=</span> dummy <span style=color:#f92672>=</span> ListNode(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> lst <span style=color:#f92672>in</span> lists:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> lst:
</span></span><span style=display:flex><span>            heapq<span style=color:#f92672>.</span>heappush(heap, HeapNode(lst))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> heap:
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> heapq<span style=color:#f92672>.</span>heappop(heap)<span style=color:#f92672>.</span>node
</span></span><span style=display:flex><span>        current<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> node
</span></span><span style=display:flex><span>        current <span style=color:#f92672>=</span> current<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>next:
</span></span><span style=display:flex><span>            heapq<span style=color:#f92672>.</span>heappush(heap, HeapNode(node<span style=color:#f92672>.</span>next))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dummy<span style=color:#f92672>.</span>next
</span></span></code></pre></div><p><strong>Iterative Mergesort on sorted lists</strong></p><ul><li>Take 2 pairs of list and sort them together</li><li>Do this iteratively until there is only 1 left</li><li>$T(n) = O(n + n/2 + n/4 + &mldr; +n/k) = O(n \log k)$</li><li>$S(n) = O(1)$</li></ul><span class=tag>linked list</span></div><div class=note id=18f><div style=text-align:right;height:5px><a name=18f href=/notes_collection/lc_notes/18f/ class="xxs grey monospace">18f</a></div><h2 id=linked-list-cycle-lc141>Linked List Cycle [LC#141]</h2><blockquote><p>Given head, the head of a linked list, determine if the linked list has a cycle in it. Return true if there is a cycle in the linked list. Otherwise, return false.</p></blockquote><h3 id=floyds-turtle-and-hare-algorithm>Floyd&rsquo;s Turtle and hare algorithm</h3><p>It relies on the fact that if two pointers are moving at different speeds within a cycle, their distances will reach a max length before being reset to zero at which point they will point to the same element.</p><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$ Will travel initial <code>n</code> of non-cyclic then <code>k</code> which is cycle length.</li><li>$S(n) = O(n)$</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>has_cycle</span>(head: Optional[ListNode]) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    turtle, hare <span style=color:#f92672>=</span> ListNode(<span style=color:#ae81ff>0</span>, head), ListNode(<span style=color:#ae81ff>0</span>, head)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> turtle <span style=color:#f92672>and</span> hare:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> turtle <span style=color:#f92672>==</span> hare:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        turtle <span style=color:#f92672>=</span> turtle<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>        hare <span style=color:#f92672>=</span> hare<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>next <span style=color:#66d9ef>if</span> hare<span style=color:#f92672>.</span>next <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span></code></pre></div><span class=tag>linked list</span></div><div class=note id=18g><div style=text-align:right;height:5px><a name=18g href=/notes_collection/lc_notes/18g/ class="xxs grey monospace">18g</a></div><h2 id=implementing-lru-cache-lc146>Implementing LRU Cache [LC#146]</h2><blockquote><p>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</p><p>Implement the LRUCache class:</p><ul><li><code>LRUCache(int capacity)</code> Initialize the LRU cache with positive size capacity.</li><li><code>int get(int key)</code> Return the value of the key if the key exists, otherwise return -1.</li><li><code>void put(int key, int value)</code> Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.
The functions get and put must each run in $O(1)$ average time complexity.</li></ul></blockquote><h3 id=intuition>Intuition</h3><ul><li>Values can be stored in a dictionary</li><li>For keeping track of freshness, we use a doubly linked list.<ul><li>New values are inserted at the right end</li><li>existing values are removed and nserted at the right end to implement recently used property</li><li>Capacity can be enforced by removing nodes from left. Nodes in the left are least recently used.</li></ul></li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, key, val, nxt<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, prev<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>key <span style=color:#f92672>=</span> key
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>val <span style=color:#f92672>=</span> val
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> nxt
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> prev
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LRUCache</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, capacity: int):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>capacity <span style=color:#f92672>=</span> capacity
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>storage <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>tail <span style=color:#f92672>=</span> Node(<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>head<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>tail
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>tail<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_at_end</span>(self, node):
</span></span><span style=display:flex><span>        node<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>tail<span style=color:#f92672>.</span>prev
</span></span><span style=display:flex><span>        node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>tail 
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>tail<span style=color:#f92672>.</span>prev<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> node
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>tail<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> node
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>remove_node</span>(self, node):
</span></span><span style=display:flex><span>        node<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>prev
</span></span><span style=display:flex><span>        node<span style=color:#f92672>.</span>prev<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node<span style=color:#f92672>.</span>key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get</span>(self, key: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> key <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>storage:
</span></span><span style=display:flex><span>            <span style=color:#75715e># update freshness</span>
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>storage[key]
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>remove_node(node)
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>add_at_end(node)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node<span style=color:#f92672>.</span>val
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>put</span>(self, key: int, value: int) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> key <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>storage:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>storage[key]<span style=color:#f92672>.</span>val <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>get(key)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> Node(key, value, <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>storage[key] <span style=color:#f92672>=</span> node
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>add_at_end(node)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> len(self<span style=color:#f92672>.</span>storage)<span style=color:#f92672>&gt;</span>self<span style=color:#f92672>.</span>capacity:
</span></span><span style=display:flex><span>                rm_key <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>remove_node(self<span style=color:#f92672>.</span>head<span style=color:#f92672>.</span>next)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>del</span> self<span style=color:#f92672>.</span>storage[rm_key]     
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$O(1)$ for get and put</li><li>$O(n)$ storage for dictionary and linkeidnlist</li></ul><span class=tag>linked list</span></div><div class=note id=18h><div style=text-align:right;height:5px><a name=18h href=/notes_collection/lc_notes/18h/ class="xxs grey monospace">18h</a></div><h2 id=remove-nodes-from-linked-list-lc2487>Remove Nodes From Linked List [LC#2487]</h2><blockquote><p>You are given the head of a linked list. Remove every node which has a node with a greater value anywhere to the right side of it. Return the head of the modified linked list.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Use a monotonic increasing stack. The nodes that are left on the stack is the answer.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>remove_nodes</span>(self, head: Optional[Node]) <span style=color:#f92672>-&gt;</span> Optional[Node]:
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    node <span style=color:#f92672>=</span> head
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> node:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> node <span style=color:#f92672>and</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>val <span style=color:#f92672>&lt;</span> node<span style=color:#f92672>.</span>val:
</span></span><span style=display:flex><span>            mid <span style=color:#f92672>=</span> stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>.</span>append(node)
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    dummy <span style=color:#f92672>=</span> node <span style=color:#f92672>=</span> Node(<span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> v <span style=color:#f92672>in</span> stack:
</span></span><span style=display:flex><span>        node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> v
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> v
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dummy<span style=color:#f92672>.</span>next
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(n)$</li></ul><span class=tag>monotonic stack</span>
<span class=tag>linked list</span></div><div class=note id=20><div style=text-align:right;height:5px><a name=20 href=/notes_collection/lc_notes/20/ class="xxs grey monospace">20</a></div><h1 id=sequences>Sequences</h1></div><div class=note id=20a><div style=text-align:right;height:5px><a name=20a href=/notes_collection/lc_notes/20a/ class="xxs grey monospace">20a</a></div><h2 id=longest-consecutive-sequence-lc128>Longest Consecutive Sequence [LC#128]</h2><blockquote><p>Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.</p></blockquote><p><strong>Brute Force</strong></p><ul><li>Consider each element as seed.</li><li>Check if next element in the sequece is in the list. keep track of sequence length</li><li>$T(n) = O(n^3)$; $S(n) = O(1)$</li></ul><p><strong>Sorting</strong></p><ul><li>Sort the array.</li><li>Check the length of longest conseqtive sequence</li><li>$T(n) = O(n \log n)$; $S(n) = O(n)$</li></ul><p><strong>Hash Table based look up</strong></p><ul><li>For each num, if num-1 is not in the list, then its possibly a sequence&rsquo;s begning</li><li>For each sequence begning, check if conseqtive elements are in the list</li><li>Each valid sequence is tested once</li><li>$T(n) = O(n)$</li><li>$S(n) = O(n)$</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>longest_consecutive_sequence</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    entries <span style=color:#f92672>=</span> set(nums)
</span></span><span style=display:flex><span>    best <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> num<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> entries:
</span></span><span style=display:flex><span>            next_num, seq_len <span style=color:#f92672>=</span> num<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> next_num <span style=color:#f92672>in</span> entries: 
</span></span><span style=display:flex><span>                next_num <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                seq_len <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            best <span style=color:#f92672>=</span> max(best, seq_len)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> best
</span></span></code></pre></div></div><div class=note id=20b><div style=text-align:right;height:5px><a name=20b href=/notes_collection/lc_notes/20b/ class="xxs grey monospace">20b</a></div><h2 id=longest-increasing-subsequence-lc300>Longest Increasing Subsequence [LC#300]</h2><blockquote><p>Given an integer array nums, return the length of the longest strictly increasing subsequence.</p></blockquote><h3 id=dynamic-programming-approach>Dynamic programming approach</h3><ul><li>Find the length of longest increasing subsequence ending at i.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>length_of_lis</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> nums: <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    max_length <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> len(nums)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, len(nums)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(i):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> nums[i] <span style=color:#f92672>&gt;</span> nums[j]:
</span></span><span style=display:flex><span>                max_length[i] <span style=color:#f92672>=</span> max(max_length[i], max_length[j] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max(max_length)
</span></span></code></pre></div></li><li>$T(n) + O(n^2)$; $S(n) = O(n)$</li></ul><h3 id=technique-based-on-patience-sorting>Technique based on <a href=https://www.cs.princeton.edu/courses/archive/spring13/cos423/lectures/LongestIncreasingSubsequence.pdf>patience sorting</a></h3><ul><li>If the number is larger than the largest element in the temporary array, append it. Otherwise, replace the found position with the current number.</li><li>The length of the temporary array will give the length of the longest increasing subsequence.</li><li>The temp array may not always have a valid subsequence, but its length will always be equal to longest subsequence.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> bisect <span style=color:#f92672>import</span> bisect_left
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>length_of_lis</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> nums: <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    tails <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>        pos <span style=color:#f92672>=</span> bisect_left(tails, num)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> pos <span style=color:#f92672>==</span> len(tails):
</span></span><span style=display:flex><span>            tails<span style=color:#f92672>.</span>append(num)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            tails[pos] <span style=color:#f92672>=</span> num
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len(tails)
</span></span></code></pre></div></li><li>$T(n) = O(n \log n)$; $S(n) = O(n)$</li></ul></div><div class=note id=20b01><div style=text-align:right;height:5px><a name=20b01 href=/notes_collection/lc_notes/20b01/ class="xxs grey monospace">20b01</a></div><h2 id=russian-doll-envelopes-lc354>Russian Doll Envelopes [LC#354]</h2><blockquote><p>You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&rsquo;s width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).
<em>Note: You cannot rotate an envelope.</em></p></blockquote><h3 id=intuition>Intuition</h3><ul><li>The problem is a 2D version of Longest Increasing Subsequence, but since the item order is not static in the original problem, we can convert it to a 1D version as follows.</li><li>If a set of envelopes share same width, then 2 in such should not be selected. To ensure this, we sort the sequence in increasing order of width and then decreasing order of height. This also ensures that when a taller one is selected, the shorter ones are not selected after that.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>russian_dolls</span>(envelopes: List[List[int]]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    envelopes<span style=color:#f92672>.</span>sort(key<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> r: (r[<span style=color:#ae81ff>0</span>], <span style=color:#f92672>-</span>r[<span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>length_of_lis(h <span style=color:#66d9ef>for</span> w, h <span style=color:#f92672>in</span> envelopes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>length_of_lis</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> nums:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    tails <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>        pos <span style=color:#f92672>=</span> bisect<span style=color:#f92672>.</span>bisect_left(tails, num)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> pos <span style=color:#f92672>==</span> len(tails):
</span></span><span style=display:flex><span>            tails<span style=color:#f92672>.</span>append(num)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            tails[pos] <span style=color:#f92672>=</span> num
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len(tails)
</span></span></code></pre></div><h3 id=run-time>Run time</h3><p>Time complexity for sorting is $O(n \log n)$ and for LIS it is $O(n \log n)$. Depending on the implementation, we need $O(n)$ extra space.</p><ul><li>$T(n) = O(n \log n)$ and $S(n) = O(n)$</li></ul></div><div class=note id=20c><div style=text-align:right;height:5px><a name=20c href=/notes_collection/lc_notes/20c/ class="xxs grey monospace">20c</a></div><h2 id=longest-common-subsequence-lc1143>Longest Common Subsequence [LC#1143]</h2><blockquote><p>Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p><p>For example, &ldquo;ace&rdquo; is a subsequence of &ldquo;abcde&rdquo;. A common subsequence of two strings is a subsequence that is common to both strings.</p></blockquote><p><strong>Dynamic programming approach</strong></p><ul><li><code>dp[i][j]</code> contains length of longest subsequence by using first <code>i-1</code> characters of first string and <code>j-1</code> characters of second string.</li><li><code>dp[i][0] = 0</code> and <code>dp[0][j] = 0</code></li><li>$T(n) = O(mn)$; $S(n) = O(mn)$<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>longest_common_subsequence</span>(text1: str, text2: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> len(text1)
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(text2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create a 2D array to store lengths of longest common subsequence.</span>
</span></span><span style=display:flex><span>    dp <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Build the dp array</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> text1[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> text2[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>                dp[i][j] <span style=color:#f92672>=</span> dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                dp[i][j] <span style=color:#f92672>=</span> max(dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j], dp[i][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># The length of the longest common subsequence is in dp[m][n]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dp[m][n]
</span></span></code></pre></div></li></ul><p><strong>Dynamic programming approach with space optimisation</strong></p><ul><li>$T(n) = O(mn)$ ; $S(n) = O(\min\{m,n\})$<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>longest_common_subsequence</span>(text1: str, text2: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(text2) <span style=color:#f92672>&gt;</span> len(text1):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> longest_common_subsequence(text2, text1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> len(text1)
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(text2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    prev <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    curr <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> text1[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> text2[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>                curr[j] <span style=color:#f92672>=</span> prev[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                curr[j] <span style=color:#f92672>=</span> max(curr[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>], prev[j])
</span></span><span style=display:flex><span>        prev, curr <span style=color:#f92672>=</span> curr, prev
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> prev[n]
</span></span></code></pre></div></li></ul></div><div class=note id=20d><div style=text-align:right;height:5px><a name=20d href=/notes_collection/lc_notes/20d/ class="xxs grey monospace">20d</a></div><h2 id=longest-palindromic-subsequence-lc516>Longest Palindromic Subsequence [LC#516]</h2><blockquote><p>Given a string <code>s</code>, find the longest palindromic subsequence&rsquo;s length in <code>s</code>. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p></blockquote><h3 id=intuition>Intuition</h3><p>If the characters at the both ends of the string sre the same, they must be part of the longest palindrome. We can add 2 to the length and remove those characters. If they are not equal, then the longest palindrome would be in either of the arrays with one of the end characters removed.</p><p><strong>Dynamic Programming</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>longest_palindrommic_subsequence</span>(s: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@cache</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>longest</span>(i, j):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> j:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&gt;</span> j:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> s[i] <span style=color:#f92672>==</span> s[j]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> longest(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> max(longest(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, j), longest(i, j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> longest(<span style=color:#ae81ff>0</span>, len(s) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n^2)$ and $S(n) = O(n^2)$</li></ul><p><strong>Dynamic Programming with space optimisation</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>longest_palindromic_subsequence</span>(s: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(s)
</span></span><span style=display:flex><span>    curr_dp, prev_dp <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n, [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        curr_dp[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, n):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> s[i] <span style=color:#f92672>==</span> s[j]:
</span></span><span style=display:flex><span>                curr_dp[j] <span style=color:#f92672>=</span> prev_dp[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                curr_dp[j] <span style=color:#f92672>=</span> max(prev_dp[j], curr_dp[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>        prev_dp <span style=color:#f92672>=</span> curr_dp[:]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> curr_dp[n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span></code></pre></div><h3 id=time-complexity-1>Time Complexity</h3><ul><li>$T(n) = O(n^2)$ and $S(n) = O(n)$</li></ul></div><div class=note id=20e><div style=text-align:right;height:5px><a name=20e href=/notes_collection/lc_notes/20e/ class="xxs grey monospace">20e</a></div><h2 id=sum-of-good-subsequences-lc3351>Sum of Good Subsequences [LC#3351]</h2><blockquote><p>You are given an integer array nums. A good subsequence is defined as a subsequence of nums where the absolute difference between any two consecutive elements in the subsequence is exactly 1. Return the sum of all possible good subsequences of nums (modulo $10^9 + 7$). Note that a subsequence of size 1 is considered good by definition.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>We can append <code>num</code> to a sequence ending in <code>num-1</code> or <code>num+1</code> or start a new good subsequence, i.e, <code>count[num] = count[num-1] + count[num+1] + 1</code></li><li>Contribution of <code>num</code> to the final sum is <code>(num * count[num])</code>. But to avoid duplicates, we iterate over the array and keep the total in another counter</li></ul><h3 id=solution>Solution</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sum_of_good_subsequences</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    mod <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>**</span> <span style=color:#ae81ff>9</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>    total <span style=color:#f92672>=</span> Counter()
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> Counter()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>        ending_at <span style=color:#f92672>=</span> count[num <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> count[num <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        total[num] <span style=color:#f92672>+=</span> total[num <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> total[num <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> num <span style=color:#f92672>*</span> ending_at
</span></span><span style=display:flex><span>        count[num] <span style=color:#f92672>+=</span> ending_at
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum(total<span style=color:#f92672>.</span>values()) <span style=color:#f92672>%</span> mod
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n)$; $S(n) = O(n)$</li></ul><span class=tag>sub sequence</span>
<span class=tag>dp</span></div><div class=note id=22><div style=text-align:right;height:5px><a name=22 href=/notes_collection/lc_notes/22/ class="xxs grey monospace">22</a></div><h1 id=palindromes>Palindromes</h1></div><div class=note id=22a><div style=text-align:right;height:5px><a name=22a href=/notes_collection/lc_notes/22a/ class="xxs grey monospace">22a</a></div><h2 id=longest-palindromic-substring-lc5>Longest Palindromic Substring [LC#5]</h2><blockquote><p>Given a string s, return the longest palindromic substring in s.</p></blockquote><h3 id=intuition>Intuition</h3><p>Expand around Center</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>longestPalindrome</span>(string: str) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>expand_around_center</span>(left: int, right: int, string: str) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> right <span style=color:#f92672>&lt;</span> len(string) <span style=color:#f92672>and</span> string[left] <span style=color:#f92672>==</span> string[right]:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> left <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> right <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> string[left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> : right]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    longest <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(s)):
</span></span><span style=display:flex><span>        longest <span style=color:#f92672>=</span> max(
</span></span><span style=display:flex><span>            longest,
</span></span><span style=display:flex><span>            expand_around_center(i, i, string),
</span></span><span style=display:flex><span>            expand_around_center(i, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, string),
</span></span><span style=display:flex><span>            key<span style=color:#f92672>=</span>len,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> longest
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n^2)$</li><li>$S(n) = O(1)$</li></ul><span class=tag>palindromes</span></div><div class=note id=22b><div style=text-align:right;height:5px><a name=22b href=/notes_collection/lc_notes/22b/ class="xxs grey monospace">22b</a></div><h2 id=count-palindromic-substrings-lc647>Count Palindromic Substrings [LC#647]</h2><blockquote><p>Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string.</p></blockquote><h3 id=intuition>Intuition</h3><p>Expand around Center</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_palindromic_substrings</span>(s: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>expand_around_center</span>(left: int, right: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> right <span style=color:#f92672>&lt;</span> len(s) <span style=color:#f92672>and</span> s[left] <span style=color:#f92672>==</span> s[right]:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> left <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> right <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            count <span style=color:#f92672>=</span> count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(s)):
</span></span><span style=display:flex><span>        <span style=color:#75715e># odd length palindromes</span>
</span></span><span style=display:flex><span>        count <span style=color:#f92672>+=</span> expand_around_center(i, i)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># even length palindromes</span>
</span></span><span style=display:flex><span>        count <span style=color:#f92672>+=</span> expand_around_center(i, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_palindromic_substrings_faster</span>(s: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> manacher(s)
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> length <span style=color:#f92672>in</span> p:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> length <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> length <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> length <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>manacher</span>(self, s):
</span></span><span style=display:flex><span>    t <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;#&#34;</span><span style=color:#f92672>.</span>join(<span style=color:#e6db74>&#34;^</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>$&#34;</span><span style=color:#f92672>.</span>format(s))
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(t)
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    center <span style=color:#f92672>=</span> right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>            p[i] <span style=color:#f92672>=</span> min(right <span style=color:#f92672>-</span> i, p[<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> center <span style=color:#f92672>-</span> i])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> t[i <span style=color:#f92672>+</span> p[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> t[i <span style=color:#f92672>-</span> p[i] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>            p[i] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>+</span> p[i] <span style=color:#f92672>&gt;</span> right:
</span></span><span style=display:flex><span>            center, right <span style=color:#f92672>=</span> i, i <span style=color:#f92672>+</span> p[i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> p[<span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n^2)$ $O(n)$ if you use manacher.</li><li>$S(n) = O(1)$</li></ul><span class=tag>palindromes</span></div><div class=note id=22c><div style=text-align:right;height:5px><a name=22c href=/notes_collection/lc_notes/22c/ class="xxs grey monospace">22c</a></div><h2 id=manacher-algorithm>Manacher Algorithm</h2><p>All palindromes in $O(1)$</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>manacher</span>(s: str):
</span></span><span style=display:flex><span>    t <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;#&#39;</span><span style=color:#f92672>.</span>join(<span style=color:#e6db74>&#39;^</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>$&#39;</span><span style=color:#f92672>.</span>format(s))
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(t)
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    center <span style=color:#f92672>=</span> right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>            p[i] <span style=color:#f92672>=</span> min(right <span style=color:#f92672>-</span> i, p[<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> center <span style=color:#f92672>-</span> i])
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> t[i <span style=color:#f92672>+</span> p[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> t[i <span style=color:#f92672>-</span> p[i] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>            p[i] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>+</span> p[i] <span style=color:#f92672>&gt;</span> right:
</span></span><span style=display:flex><span>            center, right <span style=color:#f92672>=</span> i, i <span style=color:#f92672>+</span> p[i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> p[<span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span></code></pre></div><span class=tag>palindromes</span></div><div class=note id=22d><div style=text-align:right;height:5px><a name=22d href=/notes_collection/lc_notes/22d/ class="xxs grey monospace">22d</a></div><h2 id=palindromic-partition>Palindromic Partition</h2><span class=tag>palindromes</span></div><div class=note id=23><div style=text-align:right;height:5px><a name=23 href=/notes_collection/lc_notes/23/ class="xxs grey monospace">23</a></div><h1 id=parentheses>Parentheses</h1></div><div class=note id=23a><div style=text-align:right;height:5px><a name=23a href=/notes_collection/lc_notes/23a/ class="xxs grey monospace">23a</a></div><h2 id=longest-valid-parentheses-lc32>Longest Valid Parentheses [LC32]</h2><p>Given a string containing just the characters &lsquo;(&rsquo; and &lsquo;)&rsquo;, return the length of the longest valid (well-formed) parentheses
substring</p><h3 id=using-stack>Using stack</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>longest_valid_parentheses</span>(self, s: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(s)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> s[i] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;(&#34;</span>:
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> stack:
</span></span><span style=display:flex><span>                ans <span style=color:#f92672>=</span> max(ans, i <span style=color:#f92672>-</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                stack<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n)$ and $S(n) = O(n)$</li></ul><h3 id=using-2-pointers>Using 2 pointers</h3><p>One of the passes will catch all the longest substring. Check the counter comparison condition and order of the comparisons.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>longest_valid_parentheses</span>(self, s: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> s:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;(&#39;</span>:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            right <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> right <span style=color:#f92672>==</span> left:
</span></span><span style=display:flex><span>            ans <span style=color:#f92672>=</span> max(ans, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>right)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> right <span style=color:#f92672>&gt;</span> left:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    left <span style=color:#f92672>=</span> right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> reversed(s):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;(&#39;</span>:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            right <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> right <span style=color:#f92672>==</span> left:
</span></span><span style=display:flex><span>            ans <span style=color:#f92672>=</span> max(ans, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>right)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> left <span style=color:#f92672>&gt;</span> right:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans
</span></span></code></pre></div><h3 id=time-complexity-1>Time Complexity</h3><ul><li>$T(n) = O(n)$ and $S(n) = O(1)$</li></ul><span class=tag>stack</span></div><div class=note id=23b><div style=text-align:right;height:5px><a name=23b href=/notes_collection/lc_notes/23b/ class="xxs grey monospace">23b</a></div><h2 id=valid-parenthesis-string-lc678>Valid Parenthesis String [LC#678]</h2><blockquote><p>Given a string s containing only three types of characters: <code>'('</code>, <code>')'</code> and <code>'*'</code>, return true if s is valid. The string is valid if it is a valid paranthesised string where any <code>'*'</code> could be treated as <code>'('</code> or <code>')'</code> or empty string.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li><p>there is a 2 stacks approach where one stack is used to store indices of <code>'('</code> and match with the corresponding <code>')'</code> while the other maintains indices of <code>'*'</code>.</p></li><li><p>The key observation here is to note that either the aesterics can all be left or empty OR right or empty in valid configurations. We count from both sides for either.</p></li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>valid_parenthesis</span>(string: str) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(string)
</span></span><span style=display:flex><span>    open_cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    close_cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> left, right <span style=color:#f92672>in</span> zip(range(n), range(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> string[left] <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#34;(&#34;</span>, <span style=color:#e6db74>&#34;*&#34;</span>]:
</span></span><span style=display:flex><span>            open_cnt <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            open_cnt <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> string[right] <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#34;)&#34;</span>, <span style=color:#e6db74>&#34;*&#34;</span>]:
</span></span><span style=display:flex><span>            close_cnt <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            close_cnt <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> open_cnt <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>or</span> close_cnt <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$</li></ul><span class=tag>stack</span></div><div class=note id=23c><div style=text-align:right;height:5px><a name=23c href=/notes_collection/lc_notes/23c/ class="xxs grey monospace">23c</a></div><h2 id=minimum-add-to-make-parentheses-valid-lc921>Minimum Add to Make Parentheses Valid [LC#921]</h2><blockquote><p>You are given a parentheses string <code>s</code>. In one move, you can insert a parenthesis at any position of the string. For example, if <code>s = "()))"</code>, you can insert an opening parenthesis to be <code>"(()))"</code> or a closing parenthesis to be <code>"())))"</code>.
Return the minimum number of moves required to make <code>s</code> valid.</p></blockquote><h3 id=intuition>Intuition</h3><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_valid</span>(s: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    insert_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> char <span style=color:#f92672>in</span> s:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> char <span style=color:#f92672>==</span><span style=color:#e6db74>&#39;(&#39;</span>:
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>.</span>append(char)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> char <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;)&#39;</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> stack:
</span></span><span style=display:flex><span>                stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                insert_count <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    insert_count <span style=color:#f92672>+=</span> len(stack)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> insert_count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_valid</span>(self, s: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    insert_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    open_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> char <span style=color:#f92672>in</span> s:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> char <span style=color:#f92672>==</span><span style=color:#e6db74>&#39;(&#39;</span>:
</span></span><span style=display:flex><span>            open_count<span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> char <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;)&#39;</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> open_count<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                open_count<span style=color:#f92672>-=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                insert_count <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    insert_count <span style=color:#f92672>+=</span> open_count
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> insert_count
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$. If using stack then $O(n)$.</li></ul></div><div class=note id=25><div style=text-align:right;height:5px><a name=25 href=/notes_collection/lc_notes/25/ class="xxs grey monospace">25</a></div><h1 id=two-pointers>Two Pointers</h1></div><div class=note id=25a><div style=text-align:right;height:5px><a name=25a href=/notes_collection/lc_notes/25a/ class="xxs grey monospace">25a</a></div><h2 id=containers-with-most-water-lc11>Containers with most water [LC#11]</h2><blockquote><p>Given $n$ non-negative integers $a_1$, $a_2$, &mldr; , $a_n$ , where each represents a point at coordinate $(i, a_i)$. $n$ vertical lines are drawn such that the two endpoints of the line $i$ is at $(i, a_i)$ and $(i, 0)$. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.</p></blockquote><p><strong>Two pointer approach</strong></p><ul><li>Given 2 walls, the volume of water between them is limited by the smaller one. So we can move inwards from the smaller wall.</li><li>This can be implemented using a 2 pointer approach closing in from both ends.</li><li>$T(n) = O(n)$</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>max_water</span>(height: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len(height)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    max_area <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>        max_area <span style=color:#f92672>=</span> max(
</span></span><span style=display:flex><span>            max_area, 
</span></span><span style=display:flex><span>            (right <span style=color:#f92672>-</span> left)<span style=color:#f92672>*</span>(min(height[left], height[right])) 
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        <span style=color:#75715e># we have to move away from the smaller wall</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># as it is limiting factor of the area</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> height[left] <span style=color:#f92672>&lt;</span> height[right]:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            right <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_area
</span></span></code></pre></div><span class=tag>two pointers</span></div><div class=note id=27><div style=text-align:right;height:5px><a name=27 href=/notes_collection/lc_notes/27/ class="xxs grey monospace">27</a></div><h1 id=sliding-window>Sliding Window</h1></div><div class=note id=27a><div style=text-align:right;height:5px><a name=27a href=/notes_collection/lc_notes/27a/ class="xxs grey monospace">27a</a></div><h2 id=longest-substring-without-repeating-characters-lc3>Longest Substring Without Repeating Characters [LC#3]</h2><blockquote><p>Given a string <code>s</code>, find the length of the longest substring without repeating characters.</p></blockquote><p><strong>Sliding Window and 2 pointers</strong></p><ul><li>Start with <code>left</code> and <code>right</code> at 0.</li><li>Expand: Move <code>right</code> to add characters and update counts until a repeat is found.</li><li>Shrink: Move <code>left</code> to remove characters until all are unique.</li><li>Track maximum length of the window.</li><li>$T(n) = O(n)$; $S(n) = O(|char set|)$<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>max_substring_without_repetition</span>(s: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    char_count <span style=color:#f92672>=</span> defaultdict(int)
</span></span><span style=display:flex><span>    left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> right <span style=color:#f92672>in</span> range(len(s)):
</span></span><span style=display:flex><span>        current_char <span style=color:#f92672>=</span> s[right]
</span></span><span style=display:flex><span>        char_count[current_char] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> char_count[current_char]<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            char_count[s[left]] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span>            left <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> max(ans, right<span style=color:#f92672>-</span>left<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans
</span></span></code></pre></div></li></ul><p><strong>Optimised Sliding window</strong></p><ul><li>Same as previous approach, but keep track last occurance of all characters seen so far.</li><li>Jump to the next after last occurence whenever a character is encountered again.</li><li>$T(n) = O(n)$; $S(n) = O(|char set|)$<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>max_substring_without_repetition</span>(s: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    last_found_at <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> right <span style=color:#f92672>in</span> range(len(s)):
</span></span><span style=display:flex><span>        current_char <span style=color:#f92672>=</span> s[right]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> current_char <span style=color:#f92672>in</span> last_found_at:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> max(left, last_found_at[current_char]<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        last_found_at[current_char] <span style=color:#f92672>=</span> right
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> max(ans, right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans
</span></span></code></pre></div></li></ul><span class=tag>two pointers</span>
<span class=tag>sliding window</span></div><div class=note id=27b><div style=text-align:right;height:5px><a name=27b href=/notes_collection/lc_notes/27b/ class="xxs grey monospace">27b</a></div><h2 id=string-compression-lc443>String Compression [LC#443]</h2><blockquote><p>Given an array of characters chars, compress it using the following algorithm:
Begin with an empty string s. For each group of consecutive repeating characters in chars:</p><ul><li>If the group&rsquo;s length is 1, append the character to s.</li><li>Otherwise, append the character followed by the group&rsquo;s length.</li></ul><p>The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars. After you are done modifying the input array, return the new length of the array.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Two Pointers and sliding window</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>string_compress</span>(chars: List[str]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    chars<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#34; &#34;</span>) <span style=color:#75715e># to proccess last group</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> right <span style=color:#f92672>in</span> range(len(chars)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> chars[right] <span style=color:#f92672>!=</span> chars[left]:
</span></span><span style=display:flex><span>            length <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> length <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                string <span style=color:#f92672>=</span> chars[left]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                string <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>chars[left]<span style=color:#e6db74>}{</span>length<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> string:
</span></span><span style=display:flex><span>                chars[pos] <span style=color:#f92672>=</span> c
</span></span><span style=display:flex><span>                pos <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> right
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pos
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$</li></ul><span class=tag>two pointers</span>
<span class=tag>sliding window</span></div><div class=note id=27c><div style=text-align:right;height:5px><a name=27c href=/notes_collection/lc_notes/27c/ class="xxs grey monospace">27c</a></div><h2 id=take-k-of-each-character-from-left-and-right-lc2516>Take K of Each Character From Left and Right [LC#2516]</h2><blockquote><p>You are given a string s consisting of the characters &lsquo;a&rsquo;, &lsquo;b&rsquo;, and &lsquo;c&rsquo; and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s. Return the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.</p></blockquote><h3 id=intuition>Intuition</h3><p>We are looking for a largest window that can be removed without making count of all characters going below <code>k</code></p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>take_characters</span>(s: str, k: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> : <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span> 
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> Counter({<span style=color:#e6db74>&#34;a&#34;</span>: <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;b&#34;</span>: <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;c&#34;</span>: <span style=color:#ae81ff>0</span>})
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> char <span style=color:#f92672>in</span> s:
</span></span><span style=display:flex><span>        count[char] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> min(count<span style=color:#f92672>.</span>values()) <span style=color:#f92672>&lt;</span> k:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    max_window <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> right <span style=color:#f92672>in</span> range(len(s)):
</span></span><span style=display:flex><span>        count[s[right]] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;=</span> right <span style=color:#f92672>and</span> min(count<span style=color:#f92672>.</span>values()) <span style=color:#f92672>&lt;</span> k:
</span></span><span style=display:flex><span>            count[s[left]] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            left <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        max_window <span style=color:#f92672>=</span> max(max_window, right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len(s) <span style=color:#f92672>-</span> max_window
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(|characters|)$</li></ul><span class=tag>sliding window</span></div><div class=note id=27d><div style=text-align:right;height:5px><a name=27d href=/notes_collection/lc_notes/27d/ class="xxs grey monospace">27d</a></div><h2 id=partition-labels-lc763>Partition Labels [LC#763]</h2><blockquote><p>You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>While iterating through the string, if we know the last position of each character, we can keep extending the span of sting to include to safely include c.</li><li>If the span and the current index coincide, then the string can be partitioned at the current index.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>partition_string</span>(string: str) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>    last_pos <span style=color:#f92672>=</span> defaultdict(int)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, char <span style=color:#f92672>in</span> enumerate(string):
</span></span><span style=display:flex><span>        last_pos[char] <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    lengths <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, char <span style=color:#f92672>in</span> enumerate(string):
</span></span><span style=display:flex><span>        right <span style=color:#f92672>=</span> max(right, last_pos[char])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> right <span style=color:#f92672>==</span> i:
</span></span><span style=display:flex><span>            lengths<span style=color:#f92672>.</span>append(right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> lengths
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(|c|)$</li></ul><span class=tag>sliding window</span></div><div class=note id=30><div style=text-align:right;height:5px><a name=30 href=/notes_collection/lc_notes/30/ class="xxs grey monospace">30</a></div><h1 id=trees>Trees</h1></div><div class=note id=30a><div style=text-align:right;height:5px><a name=30a href=/notes_collection/lc_notes/30a/ class="xxs grey monospace">30a</a></div><h2 id=tree-traversals>Tree Traversals</h2></div><div class=note id=30a01><div style=text-align:right;height:5px><a name=30a01 href=/notes_collection/lc_notes/30a01/ class="xxs grey monospace">30a01</a></div><h2 id=in-order>In Order</h2></div><div class=note id=30a02><div style=text-align:right;height:5px><a name=30a02 href=/notes_collection/lc_notes/30a02/ class="xxs grey monospace">30a02</a></div><h2 id=pre-order>Pre Order</h2></div><div class=note id=30a03><div style=text-align:right;height:5px><a name=30a03 href=/notes_collection/lc_notes/30a03/ class="xxs grey monospace">30a03</a></div><h2 id=post-order>Post Order</h2></div><div class=note id=30a04><div style=text-align:right;height:5px><a name=30a04 href=/notes_collection/lc_notes/30a04/ class="xxs grey monospace">30a04</a></div><h2 id=level-order>Level Order</h2></div><div class=note id=30a05><div style=text-align:right;height:5px><a name=30a05 href=/notes_collection/lc_notes/30a05/ class="xxs grey monospace">30a05</a></div><h2 id=construct-binary-tree-from-preorder-and-inorder-traversal-lc105>Construct Binary Tree from Preorder and Inorder Traversal [LC#105]</h2><blockquote><p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p></blockquote><h3 id=intuition>Intuition</h3><p>The elements in preorder represents the roots where the inorder traversal needs to be bifurcated. Maintaining a index map of inorder to quickly map to position of any element will allow quickly building the tree recursively.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>build_tree</span>(self, preorder: List[int], inorder: List[int]) <span style=color:#f92672>-&gt;</span> Optional[TreeNode]:
</span></span><span style=display:flex><span>    val_to_idx <span style=color:#f92672>=</span> {val: idx <span style=color:#66d9ef>for</span> idx, val <span style=color:#f92672>in</span> enumerate(inorder)}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>construct</span>(in_left, in_right):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> in_left <span style=color:#f92672>&gt;</span> in_right:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        val <span style=color:#f92672>=</span> preorder<span style=color:#f92672>.</span>pop(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        in_idx <span style=color:#f92672>=</span> val_to_idx[val]
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> TreeNode(val)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        node<span style=color:#f92672>.</span>left <span style=color:#f92672>=</span> construct(in_left, in_idx <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        node<span style=color:#f92672>.</span>right <span style=color:#f92672>=</span> construct(in_idx <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, in_right)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> construct(<span style=color:#ae81ff>0</span>, len(preorder) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n)$ and $S(n) = O(n)$ for the recursion stack</li></ul></div><div class=note id=30b><div style=text-align:right;height:5px><a name=30b href=/notes_collection/lc_notes/30b/ class="xxs grey monospace">30b</a></div><h2 id=binary-tree-maximum-path-sum-lc124>Binary Tree Maximum Path Sum [LC#124]</h2><blockquote><p>A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.</p><p>The path sum of a path is the sum of the node&rsquo;s values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path.</p></blockquote><p><strong>Depth first traversal</strong></p><ul><li>The answer is inspired from from Kadane&rsquo;s algorithm for max array sum</li><li>At every node, we are looking for what is max path sum of the path ending at the node and containing only the node&rsquo;s children.</li><li>Once we have that for both children, we can also calculate the max path sum of the path passing through the node.</li><li>Keep track of the maximum of such path sum&rsquo;s</li><li>$T(n) = O(n)$; $S(n) = O(h)$. recursion depth $\approx$ max height of the tree</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>binary_tree_max_path_sum</span>(root: Optional[TreeNode]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> float(<span style=color:#e6db74>&#39;-inf&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ending_with</span>(node):
</span></span><span style=display:flex><span>        <span style=color:#75715e># What is the max path sum with path ending at node</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># and the path contains only node&#39;s children?</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>nonlocal</span> ans
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> node: <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        left_gain <span style=color:#f92672>=</span> max(ending_with(node<span style=color:#f92672>.</span>left), <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        right_gain <span style=color:#f92672>=</span> max(ending_with(node<span style=color:#f92672>.</span>right), <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># max path sum of path passing through node</span>
</span></span><span style=display:flex><span>        current_max <span style=color:#f92672>=</span> left_gain <span style=color:#f92672>+</span> node<span style=color:#f92672>.</span>val <span style=color:#f92672>+</span> right_gain
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> max(ans, current_max)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        node_gain <span style=color:#f92672>=</span> max(left_gain, right_gain) <span style=color:#f92672>+</span> node<span style=color:#f92672>.</span>val
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node_gain
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ending_with(root)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans
</span></span></code></pre></div></div><div class=note id=30c><div style=text-align:right;height:5px><a name=30c href=/notes_collection/lc_notes/30c/ class="xxs grey monospace">30c</a></div><h2 id=lowest-common-ancestor>Lowest Common Ancestor</h2></div><div class=note id=30c01><div style=text-align:right;height:5px><a name=30c01 href=/notes_collection/lc_notes/30c01/ class="xxs grey monospace">30c01</a></div><h2 id=lowest-common-ancestor-of-a-binary-tree-lc236>Lowest Common Ancestor of a Binary Tree [LC#236]</h2><blockquote><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p></blockquote><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, x):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>val <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>left <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>right <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>lowest_common_ancestor</span>(root: <span style=color:#e6db74>&#34;Node&#34;</span>, p: <span style=color:#e6db74>&#34;Node&#34;</span>, q: <span style=color:#e6db74>&#34;Node&#34;</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;Node&#34;</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search</span>(node):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> node <span style=color:#f92672>in</span> [p, q, <span style=color:#66d9ef>None</span>]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node
</span></span><span style=display:flex><span>        left <span style=color:#f92672>=</span> search(node<span style=color:#f92672>.</span>left)
</span></span><span style=display:flex><span>        right <span style=color:#f92672>=</span> search(node<span style=color:#f92672>.</span>right)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> left <span style=color:#f92672>and</span> right:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> left <span style=color:#66d9ef>if</span> left <span style=color:#66d9ef>else</span> right
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> search(root)
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$ and $S(n)= O(n)$ for the recursion stack in worst case.</li></ul><p>If nodes are not guranteed to be in the tree</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>lowest_common_ancestor</span>(root: <span style=color:#e6db74>&#34;Node&#34;</span>, p: <span style=color:#e6db74>&#34;Node&#34;</span>, q: <span style=color:#e6db74>&#34;Node&#34;</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;Node&#34;</span>:
</span></span><span style=display:flex><span>    found <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search</span>(node):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>nonlocal</span> found
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> node <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>: 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> node <span style=color:#f92672>in</span> [p, q]:
</span></span><span style=display:flex><span>            found <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        left <span style=color:#f92672>=</span> search(node<span style=color:#f92672>.</span>left)
</span></span><span style=display:flex><span>        right <span style=color:#f92672>=</span> search(node<span style=color:#f92672>.</span>right)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> left <span style=color:#f92672>and</span> right:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> left <span style=color:#66d9ef>if</span> left <span style=color:#66d9ef>else</span> right
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    node <span style=color:#f92672>=</span> search(root)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> found <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span></code></pre></div></div><div class=note id=30c02><div style=text-align:right;height:5px><a name=30c02 href=/notes_collection/lc_notes/30c02/ class="xxs grey monospace">30c02</a></div><h2 id=lowest-common-ancestor-of-a-binary-search-tree-lc235>Lowest Common Ancestor of a Binary Search Tree [LC#235]</h2><blockquote><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST. According to the definition of LCA on Wikipedia: &ldquo;The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).&rdquo;</p></blockquote><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$ and $S(n)= O(n)$ for the recursion stack in worst case.</li></ul></div><div class=note id=30d><div style=text-align:right;height:5px><a name=30d href=/notes_collection/lc_notes/30d/ class="xxs grey monospace">30d</a></div><h1 id=segment-trees>Segment Trees</h1><p>The sum of the root vertex at index 1, the sums of its two child vertices at indices 2 and 3.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SegmentTree</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, arr: List[int]):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>size <span style=color:#f92672>=</span> len(arr)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>tree <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (<span style=color:#ae81ff>4</span> <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>size)  <span style=color:#75715e># Allocate space for the segment tree</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>build(arr, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, self<span style=color:#f92672>.</span>size <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>operator</span>(self, a:int, b:int):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a<span style=color:#f92672>+</span>b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>build</span>(self, array: List[int], node: int, left: int, right: int):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> left <span style=color:#f92672>==</span> right:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>tree[node] <span style=color:#f92672>=</span> array[left]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            mid <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>build(array, node <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>, left, mid)
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>build(array, node <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, right)
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>tree[node] <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>operator(self<span style=color:#f92672>.</span>tree[node <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>], self<span style=color:#f92672>.</span>tree[node <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>query</span>(self, node: int, left: int, right: int, query_left: int, query_right: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> query_left <span style=color:#f92672>&gt;</span> query_right:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> query_left <span style=color:#f92672>==</span> left <span style=color:#f92672>and</span> query_right <span style=color:#f92672>==</span> right:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>tree[node]
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (self<span style=color:#f92672>.</span>sum(node <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>, left, mid, query_left, min(query_right, mid)) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>sum(node <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, right, max(query_left, mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>), query_right))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>update</span>(self, node: int, left: int, right: int, position: int, new_value: int):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> left <span style=color:#f92672>==</span> right:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>tree[node] <span style=color:#f92672>=</span> new_value
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            mid <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> position <span style=color:#f92672>&lt;=</span> mid:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>update(node <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>, left, mid, position, new_value)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>update(node <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, right, position, new_value)
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>tree[node] <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>operator(self<span style=color:#f92672>.</span>tree[node <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>], self<span style=color:#f92672>.</span>tree[node <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>range_query</span>(self, query_left: int, query_right: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>query(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, self<span style=color:#f92672>.</span>size <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, query_left, query_right)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>point_update</span>(self, position: int, new_value: int):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>update(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, self<span style=color:#f92672>.</span>size <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, position, new_value)
</span></span></code></pre></div></div><div class=note id=30e01><div style=text-align:right;height:5px><a name=30e01 href=/notes_collection/lc_notes/30e01/ class="xxs grey monospace">30e01</a></div><h2 id=check-completeness-of-a-binary-tree-lc958>Check Completeness of a Binary Tree [LC#958]</h2><blockquote><p>Given the root of a binary tree, determine if it is a complete binary tree. In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>We do a BFS of the tree. This traverses the tree level by level.</li><li>We should not encounter a null/empty node twice before queue is empty.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_complete_tree</span>(root: Optional[TreeNode]) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque([root])
</span></span><span style=display:flex><span>    null_found <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> node:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> null_found:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append(node<span style=color:#f92672>.</span>left)
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append(node<span style=color:#f92672>.</span>right)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            null_found <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(n)$</li></ul><span class=tag>binary tree</span></div><div class=note id=32><div style=text-align:right;height:5px><a name=32 href=/notes_collection/lc_notes/32/ class="xxs grey monospace">32</a></div><h1 id=heap>Heap</h1></div><div class=note id=32a><div style=text-align:right;height:5px><a name=32a href=/notes_collection/lc_notes/32a/ class="xxs grey monospace">32a</a></div><h2 id=find-median-from-data-stream-lc295>Find Median from Data Stream [LC#295]</h2><blockquote><p>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p><ul><li>For example, for arr = [2,3,4], the median is 3.</li><li>For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.</li></ul></blockquote><h3 id=intuition>Intuition</h3><ul><li>We can easily find median if we have access to the 2 middle elements.</li><li>The middle elements are largest of the first half and smallest of the second half if the array was sorted</li><li>We can maintain first half of elements in a max heap and second half in min heap</li><li>Always maintain insertion so that max heap has at most 1 value more than the min heap</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MedianFinder</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>low <span style=color:#f92672>=</span> [] <span style=color:#75715e># stores n or n+1 elements</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>high <span style=color:#f92672>=</span> [] <span style=color:#75715e># stores n elements</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, num: int) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        val <span style=color:#f92672>=</span> heapq<span style=color:#f92672>.</span>heappushpop(self<span style=color:#f92672>.</span>low, <span style=color:#f92672>-</span>num)
</span></span><span style=display:flex><span>        heapq<span style=color:#f92672>.</span>heappush(self<span style=color:#f92672>.</span>high, <span style=color:#f92672>-</span>val)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(self<span style=color:#f92672>.</span>low) <span style=color:#f92672>&lt;</span>  len(self<span style=color:#f92672>.</span>high):
</span></span><span style=display:flex><span>            val <span style=color:#f92672>=</span> heapq<span style=color:#f92672>.</span>heappop(self<span style=color:#f92672>.</span>high)
</span></span><span style=display:flex><span>            heapq<span style=color:#f92672>.</span>heappush(self<span style=color:#f92672>.</span>low, <span style=color:#f92672>-</span>val)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_median</span>(self) <span style=color:#f92672>-&gt;</span> float:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(self<span style=color:#f92672>.</span>low) <span style=color:#f92672>&gt;</span> len(self<span style=color:#f92672>.</span>high):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>self<span style=color:#f92672>.</span>low[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#f92672>-</span>self<span style=color:#f92672>.</span>low[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>high[<span style=color:#ae81ff>0</span>])<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(\log n) $ for each insertion and median can be computed in $O(1)$ always</li><li>$S(n) = O(n)$ for the heaps</li></ul><span class=tag>heap</span></div><div class=note id=35><div style=text-align:right;height:5px><a name=35 href=/notes_collection/lc_notes/35/ class="xxs grey monospace">35</a></div><h2 id=bfs>BFS</h2><p>Template</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bfs</span>():
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque()
</span></span><span style=display:flex><span>    seen <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>    queue<span style=color:#f92672>.</span>append(start_node)
</span></span><span style=display:flex><span>    seen<span style=color:#f92672>.</span>add(start_node)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> neigh <span style=color:#f92672>in</span> neighbors(node):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> neigh <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> seen:
</span></span><span style=display:flex><span>                visit(neigh)
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append(neigh)
</span></span><span style=display:flex><span>                seen<span style=color:#f92672>.</span>add(neigh)
</span></span></code></pre></div></div><div class=note id=35a><div style=text-align:right;height:5px><a name=35a href=/notes_collection/lc_notes/35a/ class="xxs grey monospace">35a</a></div><h2 id=shortest-path-in-binary-matrix-lc1091>Shortest Path in Binary Matrix [LC#1091]</h2><blockquote><p>Given an <code>n x n</code> binary matrix grid, return the length of the shortest clear path in the matrix from top left to bottom right. If there is no clear path, return -1. The matrix is 8 connected and you can only move in cells marked 0.</p></blockquote><h3 id=intuition>Intuition</h3><p>BFS gives the shortest path in binary matrix</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>shortest_path_in_binary_matrix</span>(grid: List[List[int]]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(grid[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>neighbours</span>(x, y):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> dx, dy <span style=color:#f92672>in</span> [
</span></span><span style=display:flex><span>            (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>), (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>), (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>            (<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),           (<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>            (<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>), (<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>), (<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        ]:
</span></span><span style=display:flex><span>            nx, ny <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> dx, y <span style=color:#f92672>+</span> dy
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> nx <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>and</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> ny <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>yield</span> nx, ny
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> grid[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>or</span> grid[n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque()
</span></span><span style=display:flex><span>    seen <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>    queue<span style=color:#f92672>.</span>append((<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    seen<span style=color:#f92672>.</span>add((<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        x, y, d <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> x <span style=color:#f92672>==</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span> y <span style=color:#f92672>==</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> d
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> nx, ny <span style=color:#f92672>in</span> neighbours(x, y):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> grid[nx][ny] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> (nx, ny) <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> seen:
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append((nx, ny, d <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                seen<span style=color:#f92672>.</span>add((nx, ny))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(mn)$</li><li>$S(n) = O(mn)$</li></ul><span class=tag>bfs</span></div><div class=note id=35b><div style=text-align:right;height:5px><a name=35b href=/notes_collection/lc_notes/35b/ class="xxs grey monospace">35b</a></div><h2 id=01-matrix-lc542>01 Matrix [LC#542]</h2><blockquote><p>Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell. The distance between two cells sharing a common edge is 1.</p></blockquote><h3 id=intuition>Intuition</h3><p>BFS starting at all 0. BFS for binary graph give shortest path.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>neares_zero</span>(matrix: List[List[int]]) <span style=color:#f92672>-&gt;</span> List[List[int]]:
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> len(matrix)
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(matrix[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>neighbors</span>(x, y):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> dx, dy <span style=color:#f92672>in</span> [(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>), (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>), (<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>), (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)]:
</span></span><span style=display:flex><span>            nx, ny <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> dx, y <span style=color:#f92672>+</span> dy
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> nx <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>and</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> ny <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>yield</span> nx, ny
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque()
</span></span><span style=display:flex><span>    seen <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(m):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> matrix[x][y] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append((x, y, <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>                seen<span style=color:#f92672>.</span>add((x, y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        row, col, steps <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> nx, ny <span style=color:#f92672>in</span> neighbors(row, col):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nx, ny) <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> seen:
</span></span><span style=display:flex><span>                matrix[nx][ny] <span style=color:#f92672>=</span> steps <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append((nx, ny, steps <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                seen<span style=color:#f92672>.</span>add((nx, ny))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> matrix
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(mn)$</li><li>$S(n) = O(mn)$</li></ul><span class=tag>bfs</span></div><div class=note id=35c><div style=text-align:right;height:5px><a name=35c href=/notes_collection/lc_notes/35c/ class="xxs grey monospace">35c</a></div><h2 id=all-nodes-distance-k-in-binary-tree-lc863>All Nodes Distance K in Binary Tree [LC#863]</h2><blockquote><p>Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node. You can return the answer in any order.</p></blockquote><h3 id=intuition>Intuition</h3><p>Nodes at distance <code>k</code> can be children of the node or can be be children of one of the ancestors of the node. But without parent pointers searching for children on ancestors is very inefficient. So we create auxillary struture to maintain parent pointers and then perform BFS on the induced graph.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>nodes_at_k_hops</span>(root: TreeNode, target: TreeNode, k: int) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>    parent_node <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_parent_node</span>(parent, node):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> node:
</span></span><span style=display:flex><span>            parent_node[node] <span style=color:#f92672>=</span> parent
</span></span><span style=display:flex><span>            create_parent_node(node, node<span style=color:#f92672>.</span>left)
</span></span><span style=display:flex><span>            create_parent_node(node, node<span style=color:#f92672>.</span>right)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    create_parent_node(<span style=color:#66d9ef>None</span>, root)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># BFS</span>
</span></span><span style=display:flex><span>    visited <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque([(target, k)])
</span></span><span style=display:flex><span>    answers <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        node, distance <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> node <span style=color:#f92672>or</span> node <span style=color:#f92672>in</span> visited:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        visited<span style=color:#f92672>.</span>add(node)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> distance <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            answers<span style=color:#f92672>.</span>append(node<span style=color:#f92672>.</span>val)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>.</span>append((node<span style=color:#f92672>.</span>left, distance <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>.</span>append((node<span style=color:#f92672>.</span>right, distance <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>.</span>append((parent_node[node], distance <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> answers
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><p>Parent pointer creation is $O(n)$ and takes $O(n)$ space. BFS takes simlar space and time.</p><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(n)$</li></ul><span class=tag>binary tree</span>
<span class=tag>bfs</span></div><div class=note id=37><div style=text-align:right;height:5px><a name=37 href=/notes_collection/lc_notes/37/ class="xxs grey monospace">37</a></div><h2 id=dfs>DFS</h2></div><div class=note id=37c><div style=text-align:right;height:5px><a name=37c href=/notes_collection/lc_notes/37c/ class="xxs grey monospace">37c</a></div><h2 id=reconstruct-itinerary-lc332>Reconstruct Itinerary [LC#332]</h2><blockquote><p>You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from &ldquo;JFK&rdquo;, thus, the itinerary must begin with &ldquo;JFK&rdquo;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&ldquo;JFK&rdquo;, &ldquo;LGA&rdquo;] has a smaller lexical order than [&ldquo;JFK&rdquo;, &ldquo;LGB&rdquo;]. You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Eulerian Path , greedy DFS</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>reconstruct_iternary</span>(tickets: List[List[str]]) <span style=color:#f92672>-&gt;</span> List[str]:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Eulerian Path , greedy DFS</span>
</span></span><span style=display:flex><span>    graph <span style=color:#f92672>=</span> defaultdict(list)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> frm, to <span style=color:#f92672>in</span> sorted(tickets)[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>        graph[frm]<span style=color:#f92672>.</span>append(to)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;JFK&#34;</span>]
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> stack:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> graph[stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]:
</span></span><span style=display:flex><span>            neigh <span style=color:#f92672>=</span> graph[stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>.</span>append(neigh)
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>        ans<span style=color:#f92672>.</span>append(node)        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(E)$</li><li>$S(n) = O(E)$</li></ul><span class=tag>eulerian path</span>
<span class=tag>dfs</span></div><div class=note id=40><div style=text-align:right;height:5px><a name=40 href=/notes_collection/lc_notes/40/ class="xxs grey monospace">40</a></div><h2 id=single-source-shortest-path>Single Source Shortest Path</h2></div><div class=note id=40a><div style=text-align:right;height:5px><a name=40a href=/notes_collection/lc_notes/40a/ class="xxs grey monospace">40a</a></div><h2 id=dijkstra-algorithm>Dijkstra algorithm</h2><ul><li><code>graph = {u : [(v, w(u,v)), ..], ... }</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dijkstra</span>(graph: List[List[Tuple[int, float]]], source: int) <span style=color:#f92672>-&gt;</span> List[float]:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(graph)
</span></span><span style=display:flex><span>    distances: List[float] <span style=color:#f92672>=</span> [math<span style=color:#f92672>.</span>inf] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    distances[source] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>
</span></span><span style=display:flex><span>    heap: List[Tuple[float, int]] <span style=color:#f92672>=</span> [(<span style=color:#ae81ff>0.0</span>, source)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> heap:
</span></span><span style=display:flex><span>        curr_dist, node <span style=color:#f92672>=</span> heapq<span style=color:#f92672>.</span>heappop(heap)
</span></span><span style=display:flex><span>        <span style=color:#75715e># if curr_dist &gt; distances[node]:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#     continue</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> neighbour, weight <span style=color:#f92672>in</span> graph[node]:
</span></span><span style=display:flex><span>            dist <span style=color:#f92672>=</span> curr_dist <span style=color:#f92672>+</span> weight
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> dist <span style=color:#f92672>&lt;</span> distances[neighbour]:
</span></span><span style=display:flex><span>                distances[neighbour] <span style=color:#f92672>=</span> dist
</span></span><span style=display:flex><span>                heapq<span style=color:#f92672>.</span>heappush(heap, (dist, neighbour))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> distances
</span></span></code></pre></div><ul><li>$T(n) = O( (V+E) \log V)$<ul><li>$O(V \log{V})$: Extract the minimum node from the heap for each vertex.</li><li>$O(E \log{V})$: Time taken to insert or update distances for each edge.</li></ul></li><li>$S(n) = O(V)$</li></ul><span class=tag>dijkstra sssp</span></div><div class=note id=40a01><div style=text-align:right;height:5px><a name=40a01 href=/notes_collection/lc_notes/40a01/ class="xxs grey monospace">40a01</a></div><h2 id=cheapest-flights-within-k-stops-lc787>Cheapest Flights Within K Stops [LC#787]</h2><blockquote><p>There are <code>n</code> cities connected by some number of flights. You are given an array flights where <code>flights[i] = [from_i, to_i, price_i]</code> indicates that there is a flight from city from_i to city to_i with cost price_i. You are also given three integers <code>src</code>, <code>dst</code>, and <code>k</code>, return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>k</code> stops. If there is no such route, return -1.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Dijkstra&rsquo;s single source shortest path algorithm with added constraint to update distance only if the stops are less than limit</li><li>Can also solve with level wise BFS.</li></ul><h3 id=code--dijkstras>Code : Dijkstra&rsquo;s</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>min_distance_within_k_hops</span>(n: int, flights: List[List[int]], src: int, dst: int, k: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    graph <span style=color:#f92672>=</span> defaultdict(list)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> frm, to, price <span style=color:#f92672>in</span> flights:
</span></span><span style=display:flex><span>        graph[frm]<span style=color:#f92672>.</span>append((to, price))
</span></span><span style=display:flex><span>    dist <span style=color:#f92672>=</span> {src: math<span style=color:#f92672>.</span>inf <span style=color:#66d9ef>for</span> src <span style=color:#f92672>in</span> range(n)}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    dist[src] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    heap <span style=color:#f92672>=</span> [(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, src)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> heap:
</span></span><span style=display:flex><span>        stops, distance, node <span style=color:#f92672>=</span> heapq<span style=color:#f92672>.</span>heappop(heap)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> neigh, weight <span style=color:#f92672>in</span> graph[node]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> stops <span style=color:#f92672>&lt;=</span> k <span style=color:#f92672>and</span> dist[neigh] <span style=color:#f92672>&gt;</span> distance <span style=color:#f92672>+</span> weight:
</span></span><span style=display:flex><span>                dist[neigh] <span style=color:#f92672>=</span> distance <span style=color:#f92672>+</span> weight
</span></span><span style=display:flex><span>                heapq<span style=color:#f92672>.</span>heappush(heap, (stops <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, dist[neigh], neigh))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> dist[dst] <span style=color:#f92672>==</span> math<span style=color:#f92672>.</span>inf <span style=color:#66d9ef>else</span> dist[dst]
</span></span></code></pre></div><h3 id=time-complexity--dijkstras>Time complexity : Dijkstra&rsquo;s</h3><ul><li>$T(n) = O(N + EK \log(EK) )$</li><li>$S(n) = O(N + EK)$</li></ul><h3 id=code--level-wise-bfs>Code : Level wise BFS</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>min_distance_within_k_hops</span>(n: int, flights: List[List[int]], src: int, dst: int, k: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    graph <span style=color:#f92672>=</span> defaultdict(list)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> frm, to, price <span style=color:#f92672>in</span> flights:
</span></span><span style=display:flex><span>        graph[frm]<span style=color:#f92672>.</span>append((to, price))
</span></span><span style=display:flex><span>    dist <span style=color:#f92672>=</span> {src: math<span style=color:#f92672>.</span>inf <span style=color:#66d9ef>for</span> src <span style=color:#f92672>in</span> range(n)}
</span></span><span style=display:flex><span>    dist[src] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque([(src, <span style=color:#ae81ff>0</span>)])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    steps <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> steps <span style=color:#f92672>&lt;=</span> k <span style=color:#f92672>and</span> queue:
</span></span><span style=display:flex><span>        level_size <span style=color:#f92672>=</span> len(queue)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(level_size):
</span></span><span style=display:flex><span>            node, distance <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> neigh, weight <span style=color:#f92672>in</span> graph[node]:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> dist[neigh] <span style=color:#f92672>&gt;</span> distance <span style=color:#f92672>+</span> weight:
</span></span><span style=display:flex><span>                    dist[neigh] <span style=color:#f92672>=</span> distance <span style=color:#f92672>+</span> weight
</span></span><span style=display:flex><span>                    queue<span style=color:#f92672>.</span>append((neigh, dist[neigh]))
</span></span><span style=display:flex><span>        steps <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> dist[dst] <span style=color:#f92672>==</span> math<span style=color:#f92672>.</span>inf <span style=color:#66d9ef>else</span> dist[dst]
</span></span></code></pre></div><h3 id=time-complexity--level-wise-bfs>Time complexity : Level wise BFS</h3><ul><li>$T(n) = O(N + EK)$</li><li>$S(n) = O(N + EK)$</li></ul><span class=tag>dijkstra sssp</span>
<span class=tag>bfs</span></div><div class=note id=40b><div style=text-align:right;height:5px><a name=40b href=/notes_collection/lc_notes/40b/ class="xxs grey monospace">40b</a></div><h2 id=bellman-ford>Bellman-Ford</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bellman_ford</span>(graph, source):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Initialize distances from source to all vertices as INFINITE</span>
</span></span><span style=display:flex><span>    distances <span style=color:#f92672>=</span> {v: float(<span style=color:#e6db74>&#34;inf&#34;</span>) <span style=color:#66d9ef>for</span> v <span style=color:#f92672>in</span> graph}
</span></span><span style=display:flex><span>    distances[source] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>  <span style=color:#75715e># Distance from source to itself is always 0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Relax all edges |V| - 1 times</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(len(graph) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> graph:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> v, w <span style=color:#f92672>in</span> graph[u]:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> distances[u] <span style=color:#f92672>!=</span> float(<span style=color:#e6db74>&#34;inf&#34;</span>) <span style=color:#f92672>and</span> distances[u] <span style=color:#f92672>+</span> w <span style=color:#f92672>&lt;</span> distances[v]:
</span></span><span style=display:flex><span>                    distances[v] <span style=color:#f92672>=</span> distances[u] <span style=color:#f92672>+</span> w
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Check for negative-weight cycles</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> graph:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> v, w <span style=color:#f92672>in</span> graph[u]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> distances[u] <span style=color:#f92672>!=</span> float(<span style=color:#e6db74>&#34;inf&#34;</span>) <span style=color:#f92672>and</span> distances[u] <span style=color:#f92672>+</span> w <span style=color:#f92672>&lt;</span> distances[v]:
</span></span><span style=display:flex><span>                print(<span style=color:#e6db74>&#34;Graph contains negative weight cycle&#34;</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> distances
</span></span></code></pre></div></div><div class=note id=42><div style=text-align:right;height:5px><a name=42 href=/notes_collection/lc_notes/42/ class="xxs grey monospace">42</a></div><h2 id=minimum-spanning-tree>Minimum Spanning Tree</h2></div><div class=note id=42a><div style=text-align:right;height:5px><a name=42a href=/notes_collection/lc_notes/42a/ class="xxs grey monospace">42a</a></div><h2 id=kruskals-algorithm-for-minimum-spanning-tree>Kruskal&rsquo;s algorithm for Minimum spanning tree</h2><p>Kruskal&rsquo;s algorithm is as follows.</p><ul><li>Go in order of lowest to highest weighted edges.</li><li>Add edge to the graph if it doesn&rsquo;t create a cycle.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Edge</span>:
</span></span><span style=display:flex><span>    u: int
</span></span><span style=display:flex><span>    v: int
</span></span><span style=display:flex><span>    w: float
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>kruskal_mst</span>(num_edges: int, edges: List[Edge]) <span style=color:#f92672>-&gt;</span> Tuple[List[Edge], float]:
</span></span><span style=display:flex><span>    edges<span style=color:#f92672>.</span>sort(key<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> x: x<span style=color:#f92672>.</span>w)
</span></span><span style=display:flex><span>    dsu <span style=color:#f92672>=</span> DisjointSetUnion(num_edges)
</span></span><span style=display:flex><span>    mst <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    total_weight <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> edge <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> dsu<span style=color:#f92672>.</span>find(edge<span style=color:#f92672>.</span>u) <span style=color:#f92672>!=</span> dsu<span style=color:#f92672>.</span>find(edge<span style=color:#f92672>.</span>v):
</span></span><span style=display:flex><span>            dsu<span style=color:#f92672>.</span>union(edge<span style=color:#f92672>.</span>u, edge<span style=color:#f92672>.</span>v) 
</span></span><span style=display:flex><span>            mst<span style=color:#f92672>.</span>append(edge)
</span></span><span style=display:flex><span>            total_weight <span style=color:#f92672>+=</span> edge<span style=color:#f92672>.</span>w
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mst, total_weight
</span></span></code></pre></div><ul><li>Time Complexity: $O(m \log m + n + m) = O(m \log n)$<ul><li>$O(m \log m)$ for sorting all edges</li><li>$O(n)$ for make set on each edges</li><li>$O(m)$ for find and union on all nodes in edges</li></ul></li><li>Space Complexity: Extra space to maintaint the DSU datastructure ~ $O(n)$</li></ul><span class=tag>mst</span></div><div class=note id=42a01><div style=text-align:right;height:5px><a name=42a01 href=/notes_collection/lc_notes/42a01/ class="xxs grey monospace">42a01</a></div><h2 id=min-cost-to-connect-all-points-lc1584>Min Cost to Connect All Points [LC#1584]</h2><blockquote><p>You are given an array points representing integer coordinates of some points on a 2D-plane, where <code>points[i] = [xi, yi]</code>. The cost of connecting two points <code>[xi, yi]</code> and <code>[xj, yj]</code> is the manhattan distance between them: <code>|xi - xj| + |yi - yj|</code>. Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Generate the graph of all pairs with distance.</li><li>The answer is MST of this graph</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>min_cost_connect_points</span>(points: List[List[int]]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DSU</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self):
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>parent <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>rank <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find</span>(self, node):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> node <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>parent:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>parent[node] <span style=color:#f92672>=</span> node
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>rank[node] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>parent[node] <span style=color:#f92672>!=</span> node:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>parent[node] <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>find(self<span style=color:#f92672>.</span>parent[node])
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>parent[node]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>union</span>(self, x, y):
</span></span><span style=display:flex><span>            x <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>find(x)
</span></span><span style=display:flex><span>            y <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>find(y)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> x <span style=color:#f92672>==</span> y:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>rank[x] <span style=color:#f92672>&lt;</span> self<span style=color:#f92672>.</span>rank[y]:
</span></span><span style=display:flex><span>                x, y <span style=color:#f92672>=</span> y, x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>parent[y] <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>rank[x] <span style=color:#f92672>==</span> self<span style=color:#f92672>.</span>rank[y]:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>rank[x] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>manhattan_distance</span>(p, q):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> abs(p[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> q[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>+</span> abs(p[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> q[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    dsu <span style=color:#f92672>=</span> DSU()
</span></span><span style=display:flex><span>    edge_list <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(points)):
</span></span><span style=display:flex><span>        dsu<span style=color:#f92672>.</span>find(i)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, i):
</span></span><span style=display:flex><span>            edge_list<span style=color:#f92672>.</span>append((i, j, manhattan_distance(points[i], points[j])))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    edge_list<span style=color:#f92672>.</span>sort(key<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> r: r[<span style=color:#ae81ff>2</span>])
</span></span><span style=display:flex><span>    min_cost <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, j, d <span style=color:#f92672>in</span> edge_list:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> dsu<span style=color:#f92672>.</span>find(i) <span style=color:#f92672>!=</span> dsu<span style=color:#f92672>.</span>find(j):
</span></span><span style=display:flex><span>            min_cost <span style=color:#f92672>+=</span> d
</span></span><span style=display:flex><span>            dsu<span style=color:#f92672>.</span>union(i, j)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> min_cost
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><p>If n is number of points</p><ul><li>$T(n) = O(n^2) + O(n^2 \log n^2) + O(n^2)$ Constructing graph, sorting edges, mst construction.</li><li>$S(n) = O(n^2)$</li></ul><span class=tag>mst</span></div><div class=note id=42b><div style=text-align:right;height:5px><a name=42b href=/notes_collection/lc_notes/42b/ class="xxs grey monospace">42b</a></div><h2 id=prims-algorithm-for-minimum-spanning-tree>Prim&rsquo;s Algorithm for Minimum spanning tree</h2><ul><li>Start with adding a randomly choosen vertex to mst</li><li>Find an edge such that one vertex is in the constructed mst, the other is not and the weight is smallest. Add this edge and vertex to mst</li><li>repeat untill mst has all vertices.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Edge</span>:
</span></span><span style=display:flex><span>    u: int
</span></span><span style=display:flex><span>    v: int
</span></span><span style=display:flex><span>    w: float
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>prims_mst</span>(num_vertices: int, edges: List[Edge]) <span style=color:#f92672>-&gt;</span> Tuple[List[Edge], float]:
</span></span><span style=display:flex><span>    graph <span style=color:#f92672>=</span> {u: [] <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> range(num_vertices)}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> edge <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>        graph[edge<span style=color:#f92672>.</span>u]<span style=color:#f92672>.</span>append((edge<span style=color:#f92672>.</span>v, edge<span style=color:#f92672>.</span>w))
</span></span><span style=display:flex><span>        graph[edge<span style=color:#f92672>.</span>v]<span style=color:#f92672>.</span>append((edge<span style=color:#f92672>.</span>u, edge<span style=color:#f92672>.</span>w))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    visited <span style=color:#f92672>=</span> [<span style=color:#66d9ef>False</span>] <span style=color:#f92672>*</span> num_vertices
</span></span><span style=display:flex><span>    min_heap <span style=color:#f92672>=</span> [(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0</span>)]  <span style=color:#75715e># (weight, vertex)</span>
</span></span><span style=display:flex><span>    total_cost <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    mst_edges <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> min_heap:
</span></span><span style=display:flex><span>        weight, u <span style=color:#f92672>=</span> heapq<span style=color:#f92672>.</span>heappop(min_heap)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> visited[u]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        visited[u] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        total_cost <span style=color:#f92672>+=</span> weight
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> weight <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:  <span style=color:#75715e># Skip the initial vertex</span>
</span></span><span style=display:flex><span>            mst_edges<span style=color:#f92672>.</span>append(Edge(prev_vertex, u, weight))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> v, edge_weight <span style=color:#f92672>in</span> graph[u]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> visited[v]:
</span></span><span style=display:flex><span>                heapq<span style=color:#f92672>.</span>heappush(min_heap, (edge_weight, v))
</span></span><span style=display:flex><span>                prev_vertex <span style=color:#f92672>=</span> u  <span style=color:#75715e># Track the previous vertex for the edge</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mst_edges, total_cost, all(visited)
</span></span></code></pre></div><p>Time Complexity</p><ul><li>While loop is executed n times as the MST only has n-1 edges. This give no of times heappop is called.</li><li>The heap push is called max m times.</li><li>$T(n) = O(n \log n + m \log n) = O((m+n) \log n)$</li><li>$S(n) = O(n)$ for the heap</li></ul><span class=tag>mst</span></div><div class=note id=44><div style=text-align:right;height:5px><a name=44 href=/notes_collection/lc_notes/44/ class="xxs grey monospace">44</a></div><h2 id=topological-sort>Topological Sort</h2><h3 id=kahns-algorithm-bfs-like>Kahn&rsquo;s Algorithm (BFS-like)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>topological_sort_kahn</span>(graph: Dict[str, List[str]]) <span style=color:#f92672>-&gt;</span> List[str]:
</span></span><span style=display:flex><span>    in_degree <span style=color:#f92672>=</span> {u: <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> graph}  <span style=color:#75715e># Initialize in-degrees to 0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> graph:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> v <span style=color:#f92672>in</span> graph[u]:
</span></span><span style=display:flex><span>            in_degree[v] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># Increment in-degree for each edge</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque([u <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> in_degree <span style=color:#66d9ef>if</span> in_degree[u] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    topological_order <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        u <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()  <span style=color:#75715e># Get a vertex with in-degree 0</span>
</span></span><span style=display:flex><span>        topological_order<span style=color:#f92672>.</span>append(u)  <span style=color:#75715e># Add it to the topological order</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> v <span style=color:#f92672>in</span> graph[u]:
</span></span><span style=display:flex><span>            in_degree[v] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># Remove the edge u -&gt; v</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> in_degree[v] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:  <span style=color:#75715e># If in-degree becomes 0, add to queue</span>
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append(v)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(topological_order) <span style=color:#f92672>!=</span> len(graph):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> topological_order
</span></span></code></pre></div><p><strong>Example Graph</strong></p><pre tabindex=0><code>graph = {
    &#39;A&#39;: [&#39;C&#39;],
    &#39;B&#39;: [&#39;C&#39;, &#39;D&#39;],
    &#39;C&#39;: [&#39;E&#39;],
    &#39;D&#39;: [&#39;E&#39;],
    &#39;E&#39;: []
}
</code></pre><h3 id=dfs-like-topological-sort>DFS like topological sort</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>topological_sort_dfs</span>(graph: Dict[str, List[str]]) <span style=color:#f92672>-&gt;</span> List[str]:
</span></span><span style=display:flex><span>    WHITE, GRAY, BLACK <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    color <span style=color:#f92672>=</span> {node: WHITE <span style=color:#66d9ef>for</span> node <span style=color:#f92672>in</span> graph}
</span></span><span style=display:flex><span>    stack: List[str] <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dfs</span>(node: str) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> color[node] <span style=color:#f92672>==</span> GRAY:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span> <span style=color:#75715e># Cycle detected</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> color[node] <span style=color:#f92672>==</span> WHITE:
</span></span><span style=display:flex><span>            color[node] <span style=color:#f92672>=</span> GRAY
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> neighbor <span style=color:#f92672>in</span> graph[node]:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> dfs(neighbor):
</span></span><span style=display:flex><span>                    <span style=color:#75715e># cycle in recursion</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>            color[node] <span style=color:#f92672>=</span> BLACK
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>.</span>append(node)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> vertex <span style=color:#f92672>in</span> graph:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> color[vertex] <span style=color:#f92672>==</span> WHITE:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> dfs(vertex):  <span style=color:#75715e># If a cycle is detected</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> stack[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span></code></pre></div><span class=tag>topological sort</span></div><div class=note id=44a><div style=text-align:right;height:5px><a name=44a href=/notes_collection/lc_notes/44a/ class="xxs grey monospace">44a</a></div><h2 id=find-eventual-safe-states-lc802>Find Eventual Safe States [LC#802]</h2><blockquote><p>There is a directed graph of <code>n</code> nodes with each node labeled from <code>0</code> to <code>n - 1</code>. The graph is represented by a 0-indexed 2D integer array graph where <code>graph[i]</code> is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in <code>graph[i]</code>.</p><p>A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node). Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.</p></blockquote><h3 id=intuition>Intuition</h3><p>Terminal nodes are safe nodes. Any node whose all ougoing edge are to safe nodes are also safe. We can iteratively grow the list of safe nodes this way. Essentially, topological sort on the reverse graph.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>eventual_safe_nodes</span>(graph: List[List[int]]) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(graph)
</span></span><span style=display:flex><span>    in_degree <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    reverse_graph <span style=color:#f92672>=</span> [[] <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n)]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> node <span style=color:#f92672>in</span> graph[i]:
</span></span><span style=display:flex><span>            reverse_graph[node]<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>            in_degree[i] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    safe_nodes <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque([i <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n) <span style=color:#66d9ef>if</span> in_degree[i]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>        safe_nodes<span style=color:#f92672>.</span>append(node)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> neigh <span style=color:#f92672>in</span> reverse_graph[node]:
</span></span><span style=display:flex><span>            in_degree[neigh] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> in_degree[neigh] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append(neigh)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sorted(safe_nodes)
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><p>$T(n) = $ $S(n) = $</p><span class=tag>topological sort</span></div><div class=note id=46><div style=text-align:right;height:5px><a name=46 href=/notes_collection/lc_notes/46/ class="xxs grey monospace">46</a></div><h2 id=max-flow-min-cut>Max Flow Min Cut</h2></div><div class=note id=50><div style=text-align:right;height:5px><a name=50 href=/notes_collection/lc_notes/50/ class="xxs grey monospace">50</a></div><h1 id=intervals>Intervals</h1></div><div class=note id=50a><div style=text-align:right;height:5px><a name=50a href=/notes_collection/lc_notes/50a/ class="xxs grey monospace">50a</a></div><h2 id=merge-intervals-lc56>Merge Intervals [LC#56]</h2><p>Given an array of intervals where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p><p><strong>Sort and Itrate approach</strong></p><ul><li>Sort the intervals by start time</li><li>Iterate over the intervals one by on merging the current with the previous if there is an overlap</li><li>$T(n) = O(n \log n + n)$; $S(n) = O(n)$</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>merge_intervals</span>(intervals: List[List[int]]) <span style=color:#f92672>-&gt;</span> List[List[int]]:
</span></span><span style=display:flex><span>    intervals <span style=color:#f92672>=</span> sorted(intervals)
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> [intervals[<span style=color:#ae81ff>0</span>]]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> start, end <span style=color:#f92672>in</span> intervals[<span style=color:#ae81ff>1</span>:]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> start <span style=color:#f92672>&lt;=</span> ans[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>            ans[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> max(ans[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>], end)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            ans<span style=color:#f92672>.</span>append([start, end])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans
</span></span></code></pre></div><span class=tag>intervals</span></div><div class=note id=50b><div style=text-align:right;height:5px><a name=50b href=/notes_collection/lc_notes/50b/ class="xxs grey monospace">50b</a></div><h2 id=insert-interval-lc57>Insert Interval [LC#57]</h2><blockquote><p>You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.</p><p>Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).</p><p>Return intervals after the insertion.</p><p>Note that you don&rsquo;t need to modify intervals in-place. You can make a new array and return it.</p></blockquote><h3 id=intuition>Intuition</h3><p>Since the intervals are sorted by start time, when we loop through them in order, we will encounter 3 cases</p><ol><li>The interval ends before the new interval</li><li>The interval overlaps with the new interval</li><li>The interval starts after the new interval</li></ol><p>We handle each of the 3 cases separately</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Interval</span>:
</span></span><span style=display:flex><span>    start: float
</span></span><span style=display:flex><span>    end: float
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>insert_interval</span>(intervals: List[Interval], new: Interval) <span style=color:#f92672>-&gt;</span> List[Interval]:
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> curr <span style=color:#f92672>in</span> intervals:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> curr<span style=color:#f92672>.</span>end <span style=color:#f92672>&lt;</span> new<span style=color:#f92672>.</span>start: <span style=color:#75715e># ends before</span>
</span></span><span style=display:flex><span>            ans<span style=color:#f92672>.</span>append(curr)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> curr<span style=color:#f92672>.</span>start <span style=color:#f92672>&gt;</span> new<span style=color:#f92672>.</span>end: <span style=color:#75715e># begins after</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> new:
</span></span><span style=display:flex><span>                ans<span style=color:#f92672>.</span>append(new)
</span></span><span style=display:flex><span>                new <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>            ans<span style=color:#f92672>.</span>append(curr)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>: <span style=color:#75715e># overlap</span>
</span></span><span style=display:flex><span>            new <span style=color:#f92672>=</span> Interval(
</span></span><span style=display:flex><span>                min(curr<span style=color:#f92672>.</span>start, new<span style=color:#f92672>.</span>start), max(curr<span style=color:#f92672>.</span>end, new<span style=color:#f92672>.</span>end)
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> new: <span style=color:#75715e># handle when intervals are empty</span>
</span></span><span style=display:flex><span>        ans<span style=color:#f92672>.</span>append(new)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n)$</li></ul><span class=tag>intervals</span></div><div class=note id=50c><div style=text-align:right;height:5px><a name=50c href=/notes_collection/lc_notes/50c/ class="xxs grey monospace">50c</a></div><h2 id=min-meeting-rooms-lc253>Min meeting rooms [LC#253]</h2><blockquote><p>Meeting Rooms II :
Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Sort all meetings by their start time</li><li>Keep the ending times of currently occupied meeting rooms in the min heap</li><li>If current start time is earlier than the min heap end time, we need a new room else we can pop the top and add a new room</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>min_meeting_rooms</span>(intervals: List[List[int]]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    intervals <span style=color:#f92672>=</span> sorted(intervals)
</span></span><span style=display:flex><span>    heap <span style=color:#f92672>=</span> [intervals[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]]  <span style=color:#75715e># first end time</span>
</span></span><span style=display:flex><span>    meeting_rooms <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> start_time, end_time <span style=color:#f92672>in</span> intervals[<span style=color:#ae81ff>1</span>:]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> start_time <span style=color:#f92672>&gt;=</span> heap[<span style=color:#ae81ff>0</span>]:
</span></span><span style=display:flex><span>            heapq<span style=color:#f92672>.</span>heappop(heap)
</span></span><span style=display:flex><span>        heapq<span style=color:#f92672>.</span>heappush(heap, end_time)
</span></span><span style=display:flex><span>        meeting_rooms <span style=color:#f92672>=</span> max(meeting_rooms, len(heap))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> meeting_rooms
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n \log n + n \log n)$ sorting + n pops</li><li>$S(n) = O(n)$</li></ul><span class=tag>intervals</span>
<span class=tag>greedy</span></div><div class=note id=50d><div style=text-align:right;height:5px><a name=50d href=/notes_collection/lc_notes/50d/ class="xxs grey monospace">50d</a></div><h2 id=line-sweep>Line Sweep</h2><p>This is a technique where we sweep an imaginary line across the whole domain, and the line&rsquo;s intersections with intervals are used to solve problems. They are particularly useful for problems where we have range updates and we need to find the final state of the array.</p><p>Say we are given <code>queries = [(left, right, value),]</code> implying all values in <code>[left, right]</code> are to be incremented by <code>value</code>. To quickly find the final value, we can do the following.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply_range_updates</span>(queries, n):
</span></span><span style=display:flex><span>    arr <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span>n
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> left, right, value <span style=color:#f92672>in</span> queries:
</span></span><span style=display:flex><span>        arr[left] <span style=color:#f92672>+=</span> value
</span></span><span style=display:flex><span>        arr[right] <span style=color:#f92672>-=</span> value
</span></span><span style=display:flex><span>    prev <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        prev<span style=color:#f92672>+=</span>arr[i]
</span></span><span style=display:flex><span>        arr[i] <span style=color:#f92672>=</span> prev
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> arr
</span></span></code></pre></div><p>The function <code>apply_range_updates</code> takes the list of queries and the size of the array <code>n</code>, and returns the final state of the array after applying all the range updates.</p><span class=tag>line sweep</span></div><div class=note id=50d01><div style=text-align:right;height:5px><a name=50d01 href=/notes_collection/lc_notes/50d01/ class="xxs grey monospace">50d01</a></div><h2 id=zero-array-transformation-i-lc3355>Zero Array Transformation I [LC#3355]</h2><blockquote><p>You are given an integer array nums of length n and a 2D array queries, where <code>queries[i] = [li, ri]</code>. For each <code>queries[i]</code>:</p><ul><li>Select a subset of indices within the range [li, ri] in nums.</li><li>Decrement the values at the selected indices by 1.</li></ul><p>A Zero Array is an array where all elements are equal to 0. Return true if it is possible to transform nums into a Zero Array after processing all the queries sequentially, otherwise return false.</p></blockquote><h3 id=intuition>Intuition</h3><p>The key idea is to find the maximum possible decrements that can be applied to each element in the array. If the maximum possible decrements for any element is less than the initial value of that element, then it is not possible to transform the array into a Zero Array. We can use a line sweep approach to efficiently compute the maximum possible decrements for each element.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_zero_array</span>(nums: List[int], queries: List[List[int]]) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>    arr <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> left, right <span style=color:#f92672>in</span> queries:
</span></span><span style=display:flex><span>        arr[left] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> right <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>            arr[right <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    prev <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        prev <span style=color:#f92672>+=</span> arr[i]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> prev <span style=color:#f92672>&lt;</span> nums[i]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><h3 id=timecomplexity>TimeComplexity</h3><ul><li>$T(n) = O(n)$ and $S(n) = O(n)$</li></ul><span class=tag>line sweep</span></div><div class=note id=50d02><div style=text-align:right;height:5px><a name=50d02 href=/notes_collection/lc_notes/50d02/ class="xxs grey monospace">50d02</a></div><h2 id=zero-array-transformation-ii-lc3356>Zero Array Transformation II [LC#3356]</h2><blockquote><p>You are given an integer array nums of length <code>n</code> and a 2D array queries where <code>queries[i] = [l_i, r_i, val_i]</code>. Each <code>queries[i]</code> represents the following action on nums:</p><ul><li>Decrement the value at each index in the range <code>[l_i, r_i]</code> in nums by at most <code>val_i</code>.</li><li>The amount by which each value is decremented can be chosen independently for each index.
A Zero Array is an array with all its elements equal to 0. Return the minimum possible non-negative value of <code>k</code>, such that after processing the first <code>k</code> queries in sequence, nums becomes a Zero Array. If no such <code>k</code> exists, return <code>-1</code>.</li></ul></blockquote><h3 id=intuition>Intuition</h3><p>Line sweep and binary search on min queries required.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>minZeroArray</span>(nums: List[int], queries: List[List[int]]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    n, m <span style=color:#f92672>=</span> len(nums), len(queries)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply_query</span>(T) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>        arr <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> left, right, val <span style=color:#f92672>in</span> queries[:T]:
</span></span><span style=display:flex><span>            arr[left] <span style=color:#f92672>+=</span> val
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> right <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>                arr[right <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>-=</span> val
</span></span><span style=display:flex><span>        prev <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>+=</span> arr[i]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> prev <span style=color:#f92672>&lt;</span> nums[i]:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    L, R <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, m
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> apply_query(m):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> L <span style=color:#f92672>&lt;</span> R:
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> L <span style=color:#f92672>+</span> (R <span style=color:#f92672>-</span> L) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> apply_query(mid):
</span></span><span style=display:flex><span>            R <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            L <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> R
</span></span></code></pre></div><h3 id=timecomplexity>TimeComplexity</h3><p>If $n$ is the size of array and $m$ is number of queries, then</p><ul><li>$T(n) = O(n \log m)$ and $S(n) = O(n)$</li></ul><span class=tag>line sweep</span>
<span class=tag>binary search</span></div><div class=note id=50d03><div style=text-align:right;height:5px><a name=50d03 href=/notes_collection/lc_notes/50d03/ class="xxs grey monospace">50d03</a></div><h2 id=smallest-range-covering-elements-from-k-lists-lc632>Smallest Range Covering Elements from K Lists [LC#632]</h2><blockquote><p>You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists. We define the range <code>[a, b]</code> is smaller than range <code>[c, d] if b - a &lt; d - c or a &lt; c if b - a == d - c</code>.</p></blockquote><h3 id=intution>Intution</h3><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>smallestRange</span>(nums: List[List[int]]) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>    heap <span style=color:#f92672>=</span> [(arr[<span style=color:#ae81ff>0</span>], i, <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>for</span> i, arr <span style=color:#f92672>in</span> enumerate(nums)]
</span></span><span style=display:flex><span>    heapq<span style=color:#f92672>.</span>heapify(heap)
</span></span><span style=display:flex><span>    right <span style=color:#f92672>=</span> max(arr[<span style=color:#ae81ff>0</span>] <span style=color:#66d9ef>for</span> arr <span style=color:#f92672>in</span> nums)
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> (<span style=color:#f92672>-</span>math<span style=color:#f92672>.</span>inf, math<span style=color:#f92672>.</span>inf)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> heap:
</span></span><span style=display:flex><span>        left, row, col <span style=color:#f92672>=</span> heapq<span style=color:#f92672>.</span>heappop(heap)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>&lt;</span> ans[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> ans[<span style=color:#ae81ff>0</span>]:
</span></span><span style=display:flex><span>            ans <span style=color:#f92672>=</span> left, right
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> col <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> len(nums[row]):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> ans
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        next_point <span style=color:#f92672>=</span> nums[row][col <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        right <span style=color:#f92672>=</span> max(right, next_point)
</span></span><span style=display:flex><span>        heapq<span style=color:#f92672>.</span>heappush(heap, (next_point, row, col <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><p>$n$ max size of lists and $m$ is number of lists</p><ul><li>$T(n) = O(n \log m)$. $S(n) = O(m)$</li></ul><span class=tag>line sweep</span>
<span class=tag>intervals</span></div><div class=note id=50e><div style=text-align:right;height:5px><a name=50e href=/notes_collection/lc_notes/50e/ class="xxs grey monospace">50e</a></div><h2 id=minimum-number-of-arrows-to-burst-balloons-lc452>Minimum Number of Arrows to Burst Balloons [LC#452]</h2><blockquote><p>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.</p><p>Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</p><p>Given the array points, return the minimum number of arrows that must be shot to burst all balloons.</p></blockquote><h3 id=intuition-greedy-approach>Intuition: Greedy Approach</h3><ul><li>This problem is about find min vertical lines intersecting a given set of intervals.</li><li>We pick an interval as a root interval. Any interval intersecting with this one can all be taken out by a single arrow.</li><li>To find minimum such sets, we sort the interval by ending time, pick first interval as root, and find the intesecting intervals to it by checking the ones whose start time is earlier.</li><li>Iteratively we can find all such combinations.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>min_arrows</span>(balloons: List[List[int]]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> balloons:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    balloons<span style=color:#f92672>.</span>sort(key <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> r: r[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>    end_location <span style=color:#f92672>=</span> balloons[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    num_arrows <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> balloon <span style=color:#f92672>in</span> balloons:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> balloon[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;</span> end_location:
</span></span><span style=display:flex><span>            end_location <span style=color:#f92672>=</span> balloon[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            num_arrows <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> num_arrows
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><p>Time complexity is domniated by sorting. $T(n) = O(n \log n) + O(n)$ , $S(n) = O(1)$</p><span class=tag>intervals</span>
<span class=tag>greedy</span></div><div class=note id=60><div style=text-align:right;height:5px><a name=60 href=/notes_collection/lc_notes/60/ class="xxs grey monospace">60</a></div><h2 id=monotonic-stack>Monotonic Stack</h2><p>A monotonic decreasing stack is a data structure based on a stack. While traversing an array, it maintains a sorted list of elements encountered so far that are strictly greater than or equal to the current element being processed. It upholds this property by continuously removing elements from the top of the stack that violate the requirement (i.e., elements that are less than the current element).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;=</span> num:
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>.</span>append(num)
</span></span><span style=display:flex><span>    <span style=color:#75715e># stack[-1] &gt; stack[-2] &gt; ... &gt; stack[0]</span>
</span></span></code></pre></div><p>Although a monotonic stack can be used to solve problems that require finding previous smaller (or larger) elements from the stack, a more interesting use is to exploit the interim states of the monotonic stack while it updates itself to maintain the property of monotonicity. Ex.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>arr<span style=color:#f92672>.</span>append(<span style=color:#f92672>-</span>math<span style=color:#f92672>.</span>inf) <span style=color:#75715e># to ensure all elements are processed</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> idx range(len(arr)):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> arr[stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]] <span style=color:#f92672>&lt;=</span> arr[idx]:
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>        left <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> stack <span style=color:#66d9ef>else</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        right <span style=color:#f92672>=</span> idx
</span></span><span style=display:flex><span>        <span style=color:#75715e># do something with arr[left] &gt; a[mid] &lt; a[right]</span>
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>.</span>append(idx)
</span></span></code></pre></div><p>References</p><ul><li><a href=https://labuladong.gitbook.io/algo-en/ii.-data-structure/monotonicstack>https://labuladong.gitbook.io/algo-en/ii.-data-structure/monotonicstack</a></li><li><a href=https://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems>https://leetcode.com/discuss/study-guide/2347639/A-comprehensive-guide-and-template-for-monotonic-stack-based-problems</a></li></ul><span class=tag>monotonic stack</span></div><div class=note id=60a><div style=text-align:right;height:5px><a name=60a href=/notes_collection/lc_notes/60a/ class="xxs grey monospace">60a</a></div><h2 id=largest-rectangle-in-histogram--lc-84>Largest Rectangle in Histogram [ LC# 84]</h2><p>Given an array of integers heights representing the histogram&rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.</p><h3 id=brute-force>Brute Force</h3><ul><li>Enumerate every range. Compute the Area</li><li>$T(n) = O(n^2)$; $S(n) = O(n^2)$</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>area[i][j] <span style=color:#f92672>=</span> min_heights[i:j] <span style=color:#f92672>*</span> ( j<span style=color:#f92672>-</span>i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>min_heights[i:j] <span style=color:#f92672>=</span> min(min_heights[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>:j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], heights[i], heights[j])
</span></span><span style=display:flex><span>min_heights[i:i] <span style=color:#f92672>=</span> heights[i]
</span></span></code></pre></div><h3 id=intuition-monotonic-stack>Intuition: Monotonic Stack</h3><ul><li>If we are at a rectangle of height $h$ and we are interested in finding the largest rectangle with minimum height $h$ in the histogram. We can extend the rectangle to both the sides till we encounter a height that is smaller.</li><li>If we trasverse the histogram from left to right and maintain a non-decreasing monotonic stack, it will have all these states that we need.</li></ul><pre tabindex=0><code>           ┌─┐         ┌─┐    
       ┌─┐ │ │       ┌─┤ │    
   ┌─┐ │ ├─┤ │     ┌─┤ │ │    
   │ ├─┤ │ │ │   ┌─┤ │ │ │    
   │ │ │ │ │ │...│h│ │ │ ├─┐   
 ┌─┤ │ │ │ │ │   │ │ │ │ │ │   
 └─┴─┴─┴─┴─┴─┘   └─┴─┴─┴─┴─┘   
   └─────────────────────┘                
┌─┴──┐          ┌─┴─┐  ┌──┴──┐
 left            mid    right
</code></pre><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>largest_rectangle_in_historgam</span>(heights: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#75715e># monotonic stack : non decreasing order</span>
</span></span><span style=display:flex><span>    max_area <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    heights<span style=color:#f92672>.</span>append(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(heights)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> heights[stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]] <span style=color:#f92672>&gt;</span> heights[i]:
</span></span><span style=display:flex><span>            mid <span style=color:#f92672>=</span> stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>            max_area <span style=color:#f92672>=</span> max(max_area,  heights[mid] <span style=color:#f92672>*</span> (right <span style=color:#f92672>-</span> left))
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_area
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$; $S(n) = O(n)$</li></ul><span class=tag>monotonic stack</span></div><div class=note id=60b><div style=text-align:right;height:5px><a name=60b href=/notes_collection/lc_notes/60b/ class="xxs grey monospace">60b</a></div><h2 id=sum-of-subarray-minimums-lc907>Sum of Subarray Minimums [LC#907]</h2><blockquote><p>Given an array of integers <code>arr</code>, find the sum of <code>min(b)</code>, where <code>b</code> ranges over every (contiguous) subarray of <code>arr</code>. Since the answer may be large, return the answer modulo $10^9 + 7$.</p></blockquote><h3 id=intuition>Intuition</h3><p>If <code>arr[k]</code> is minimum element in <code>[i, j]</code>, then <code>arr[k]</code> appears in <code>(k - i) * (j - k)</code> subarrays.</p><p><strong>Monotonic Stack</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sum_subarrray_mins</span>(arr: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    sum_of_minimums <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    arr<span style=color:#f92672>.</span>append(<span style=color:#f92672>-</span>math<span style=color:#f92672>.</span>inf) <span style=color:#75715e># so that everything gets popped out in the end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(arr)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> arr[stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]] <span style=color:#f92672>&gt;=</span> arr[i]:
</span></span><span style=display:flex><span>            mid <span style=color:#f92672>=</span> stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> stack <span style=color:#66d9ef>else</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            count <span style=color:#f92672>=</span> (mid <span style=color:#f92672>-</span> left) <span style=color:#f92672>*</span> (right <span style=color:#f92672>-</span> mid)
</span></span><span style=display:flex><span>            sum_of_minimums <span style=color:#f92672>+=</span> (count <span style=color:#f92672>*</span> arr[mid])
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum_of_minimums
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n)$ ; $S(n) = O(n)$</li></ul><span class=tag>monotonic stack</span></div><div class=note id=60c><div style=text-align:right;height:5px><a name=60c href=/notes_collection/lc_notes/60c/ class="xxs grey monospace">60c</a></div><h2 id=daily-temperatures-lc739>Daily Temperatures [LC#739]</h2><blockquote><p>Given an array of integers temperatures represents the daily temperatures, return an array answer such that <code>answer[i]</code> is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep <code>answer[i] == 0</code> instead.</p></blockquote><h3 id=intuition>Intuition</h3><p>We have to fine the next largest in the array for every element.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>next_warmer_day</span>(temperatures: List[int]) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(temperatures)
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    answers <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> temperatures[stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]] <span style=color:#f92672>&lt;=</span> temperatures[i]:
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> stack:
</span></span><span style=display:flex><span>            answers[i] <span style=color:#f92672>=</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> i
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> answers
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>OR
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>next_warmer_day</span>(temperatures: List[int]) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(temperatures)
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    answers <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> curr_day <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> temperatures[stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]] <span style=color:#f92672>&lt;</span> temperatures[curr_day]:
</span></span><span style=display:flex><span>            prev_day <span style=color:#f92672>=</span> stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>            answers[prev_day] <span style=color:#f92672>=</span> curr_day <span style=color:#f92672>-</span> prev_day
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>.</span>append(curr_day)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> answers
</span></span></code></pre></div><p><em>Note the different comparison signs between 2 implementation</em></p><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n)$ ; $S(n) = O(n)$</li></ul><span class=tag>monotonic stack</span></div><div class=note id=65><div style=text-align:right;height:5px><a name=65 href=/notes_collection/lc_notes/65/ class="xxs grey monospace">65</a></div><h1 id=tries>Tries</h1></div><div class=note id=65a><div style=text-align:right;height:5px><a name=65a href=/notes_collection/lc_notes/65a/ class="xxs grey monospace">65a</a></div><h2 id=word-break-lc139>Word break [LC#139]</h2><blockquote><p>Given a string and a vocabulary, return true if the string can be segmented into a space-separated sequence of one or more words from the vocabulary. Note that the same word in the vocabulary may be reused multiple times in the segmentation.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Use a Trie for efficient prefix searching.</li><li>Use a boolean array <code>reachable</code> to track if substrings can be segmented.</li><li>From each reachable index, use the trie search to find more reachable index</li><li>Return <code>reachable[n]</code> to determine if the entire string can be segmented.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>word_break</span>(string: str, vocabulary: List[str]) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(string)
</span></span><span style=display:flex><span>    TRIE <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    EOW <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;$&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> vocabulary:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(word) <span style=color:#f92672>&gt;</span> n:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> TRIE
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> char <span style=color:#f92672>in</span> word:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> char <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> node:
</span></span><span style=display:flex><span>                node[char] <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> node[char]
</span></span><span style=display:flex><span>        node[EOW] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    reachable <span style=color:#f92672>=</span> [<span style=color:#66d9ef>False</span>] <span style=color:#f92672>*</span> (n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    reachable[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> reachable[i]:
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> TRIE
</span></span><span style=display:flex><span>            j <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> j <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> string[j] <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> node:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>                node <span style=color:#f92672>=</span> node[string[j]]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> EOW <span style=color:#f92672>in</span> node:
</span></span><span style=display:flex><span>                    reachable[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>                j <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> reachable[n]
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><p><code>n = len(string), m = len(vocabulary), k = max(len(word) in vocabulary)</code></p><ul><li>$T(n) = O(mk) + O(nk)$ trie construction and search</li><li>$S(n) = O(mk) + O(n)$ trie and reachable</li></ul><span class=tag>trie</span>
<span class=tag>dp</span></div><div class=note id=70><div style=text-align:right;height:5px><a name=70 href=/notes_collection/lc_notes/70/ class="xxs grey monospace">70</a></div><h2 id=permutations>Permutations</h2></div><div class=note id=70a><div style=text-align:right;height:5px><a name=70a href=/notes_collection/lc_notes/70a/ class="xxs grey monospace">70a</a></div><h2 id=next-permutation-lc31>Next Permutation [LC#31]</h2><blockquote><p>Given an array of integers nums, find the next permutation of nums.</p><p>The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>[Step 1] Find the largest <code>i</code> such that <code>nums[i] &lt; nums[i+1]</code>. If no such index exists, then this is the last sequence in the permutation. Reset array to sorted order (first element in the sequence).</li><li>[Step 2] Find the largest index <code>j > i</code> such that <code>nums[i] &lt; nums[j]</code>. Swap these 2 numbers</li><li>[Step 3] Reverse the array from <code>i+1</code> till the end.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>next_permutation</span>(self, nums: List[int]) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>swap</span>(i, j):
</span></span><span style=display:flex><span>            nums[i], nums[j] <span style=color:#f92672>=</span> nums[j], nums[i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>reverse</span>(start, end):
</span></span><span style=display:flex><span>            nums[start : end <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> nums[start : end <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> : <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>        <span style=color:#75715e># Step 1</span>
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> nums[i] <span style=color:#f92672>&gt;=</span> nums[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>            i <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># Step 2</span>
</span></span><span style=display:flex><span>            j <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> nums[i] <span style=color:#f92672>&gt;=</span> nums[j]:
</span></span><span style=display:flex><span>                j <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            swap(i, j)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Step 3</span>
</span></span><span style=display:flex><span>        reverse(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> nums
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$</li></ul><span class=tag>permutation</span></div><div class=note id=70b><div style=text-align:right;height:5px><a name=70b href=/notes_collection/lc_notes/70b/ class="xxs grey monospace">70b</a></div><h2 id=permutation-sequence-lc60>Permutation Sequence [LC#60]</h2><blockquote><p>The set <code>[1, 2, 3, ..., n]</code> contains a total of <code>n!</code> unique permutations. Given <code>n</code> and <code>k</code>, return the <code>kth</code> permutation sequence.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Let $F$ be the factorial number system representation of the number $k$ for the base $n$. Indexing of $k$ starts from $0$.</li><li>For each digit $f$ in $F$, select the $f^{th}$ digit from the set of numbers and add it to the answer. After selecting, remove that digit from set.</li><li>Example:<ul><li>For $n=6$, $2982 = 4:0:4:1:0:0:0_!$ so the permutation is $(4,0,6,2,1,3,5)$</li></ul></li><li>Reference<ul><li><a href=https://en.wikipedia.org/wiki/Factorial_number_system>Factorial Number System</a></li></ul></li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>kth_permutation</span>(n: int, k: int) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>    factorials <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    digits <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;1&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n):
</span></span><span style=display:flex><span>        factorials<span style=color:#f92672>.</span>append(factorials[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> i)
</span></span><span style=display:flex><span>        digits<span style=color:#f92672>.</span>append(str(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    output <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    k <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#75715e># index = k // factorials[i]</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># k = k - idx * factorials[i]</span>
</span></span><span style=display:flex><span>        index, k <span style=color:#f92672>=</span> divmod(k, factorials[i])
</span></span><span style=display:flex><span>        output<span style=color:#f92672>.</span>append(digits[index])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>del</span> digits[index]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(output)
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(n)$</li></ul><span class=tag>permutation</span></div><div class=note id=72><div style=text-align:right;height:5px><a name=72 href=/notes_collection/lc_notes/72/ class="xxs grey monospace">72</a></div><h1 id=sets>Sets</h1></div><div class=note id=72a><div style=text-align:right;height:5px><a name=72a href=/notes_collection/lc_notes/72a/ class="xxs grey monospace">72a</a></div><h2 id=subsets-ii-lc90>Subsets II [LC#90]</h2><blockquote><p>Given an integer array <code>nums</code> that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Consider elements with duplicate as 1 element</li><li>when we need to add this element to subset, we add it once per each frequency</li><li>$T(n) = O(2^n)$; $S(n) = O(2^n)$</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>subsets_of_multiset</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> List[List[int]]:
</span></span><span style=display:flex><span>    powerset <span style=color:#f92672>=</span> [[],]
</span></span><span style=display:flex><span>    freq <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>        freq[num] <span style=color:#f92672>=</span> freq<span style=color:#f92672>.</span>get(num, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num, num_freq <span style=color:#f92672>in</span> freq<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> subset <span style=color:#f92672>in</span> ans:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> ff <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, num_freq <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>                new_subset <span style=color:#f92672>=</span> subset <span style=color:#f92672>+</span> [num] <span style=color:#f92672>*</span> ff
</span></span><span style=display:flex><span>                curr<span style=color:#f92672>.</span>append(new_subset)
</span></span><span style=display:flex><span>        powerset<span style=color:#f92672>.</span>extend(curr)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> powerset
</span></span></code></pre></div></div><div class=note id=72c><div style=text-align:right;height:5px><a name=72c href=/notes_collection/lc_notes/72c/ class="xxs grey monospace">72c</a></div><h2 id=dsu-with-rollbacks>DSU with Rollbacks</h2><ul><li>We do not add path compression as addition of roll back will results in unnecessary operations. This results in O(log n) for find (due to merge by rank)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DSU_rollback</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>parent <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>rank <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>history <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find</span>(self, v):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> v <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>parent:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>parent[v] <span style=color:#f92672>=</span> v
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>rank[v] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> self<span style=color:#f92672>.</span>parent[v]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> v
</span></span><span style=display:flex><span>        <span style=color:#75715e># self.parent[v] = self.find(self.parent[v])</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># We don&#39;t perform path compression</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>find(self<span style=color:#f92672>.</span>parent[v])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>union</span>(self, v, u):
</span></span><span style=display:flex><span>        v <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>find(v)
</span></span><span style=display:flex><span>        u <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>find(u)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> u:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>rank[v] <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>.</span>rank[u]:
</span></span><span style=display:flex><span>            v, u <span style=color:#f92672>=</span> u, v
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>history<span style=color:#f92672>.</span>append((v, self<span style=color:#f92672>.</span>rank[v], u, self<span style=color:#f92672>.</span>rank[u]))
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>parent[v] <span style=color:#f92672>=</span> u
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>rank[v] <span style=color:#f92672>==</span> self<span style=color:#f92672>.</span>rank[u]:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>rank[u] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rollback</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>history:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        v, rank_v, u, rank_u <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>history<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>parent[v] <span style=color:#f92672>=</span> v
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>rank[v] <span style=color:#f92672>=</span> rank_v
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>parent[u] <span style=color:#f92672>=</span> u
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>rank[u] <span style=color:#f92672>=</span> rank_u
</span></span></code></pre></div></div><div class=note id=73><div style=text-align:right;height:5px><a name=73 href=/notes_collection/lc_notes/73/ class="xxs grey monospace">73</a></div><h2 id=dsu-union-find>DSU Union-Find</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DSU</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>parent <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>rank <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find</span>(self, x):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> x <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>parent:
</span></span><span style=display:flex><span>            <span style=color:#75715e># new node</span>
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>parent[x] <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>rank[x] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>parent[x] <span style=color:#f92672>!=</span> x:
</span></span><span style=display:flex><span>            <span style=color:#75715e># path compression</span>
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>parent[x] <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>find(self<span style=color:#f92672>.</span>parent[x])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>parent[x]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>union</span>(self, x, y):
</span></span><span style=display:flex><span>        root_x <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>find(x)
</span></span><span style=display:flex><span>        root_y <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>find(y)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> root_x <span style=color:#f92672>==</span> root_y:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>rank[root_x] <span style=color:#f92672>&lt;</span> self<span style=color:#f92672>.</span>rank[root_y]:
</span></span><span style=display:flex><span>            root_x, root_y <span style=color:#f92672>=</span> root_y, root_x 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>parent[root_y] <span style=color:#f92672>=</span> root_x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>rank[root_x] <span style=color:#f92672>==</span> self<span style=color:#f92672>.</span>rank[root_y]:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>rank[root_x] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div></div><div class=note id=73a><div style=text-align:right;height:5px><a name=73a href=/notes_collection/lc_notes/73a/ class="xxs grey monospace">73a</a></div><h2 id=number-of-connected-components-in-an-undirected-graph-lc323>Number of Connected Components in an Undirected Graph [LC#323]</h2><blockquote><p>You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph. Return the number of connected components in the graph.</p></blockquote><h3 id=intuition>Intuition</h3><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_components</span>(self, n: int, edges: List[List[int]]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    parent <span style=color:#f92672>=</span> {i: i <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n)}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find</span>(a):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> parent[a] <span style=color:#f92672>!=</span> a:
</span></span><span style=display:flex><span>            parent[a] <span style=color:#f92672>=</span> find(parent[a])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> parent[a]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>union</span>(a, b):
</span></span><span style=display:flex><span>        a <span style=color:#f92672>=</span> find(a)
</span></span><span style=display:flex><span>        b <span style=color:#f92672>=</span> find(b)
</span></span><span style=display:flex><span>        parent[b] <span style=color:#f92672>=</span> a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> a, b <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>        union(a, b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> a, b <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>        find(a)
</span></span><span style=display:flex><span>        find(b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len(set(v <span style=color:#66d9ef>for</span> k, v <span style=color:#f92672>in</span> union_find<span style=color:#f92672>.</span>items()))
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(V + E\alpha(n))$</li><li>$S(n) = O(V)$</li></ul><span class=tag>dsu</span></div><div class=note id=73b><div style=text-align:right;height:5px><a name=73b href=/notes_collection/lc_notes/73b/ class="xxs grey monospace">73b</a></div><h2 id=the-earliest-moment-when-everyone-become-friends-lc1101>The Earliest Moment When Everyone Become Friends [LC#1101]</h2><blockquote><p>There are n people in a social group labeled from <code>0</code> to <code>n - 1</code>. You are given an array logs where <code>logs[i] = [timestampi, xi, yi]</code> indicates that <code>xi</code> and <code>yi</code> will be friends at the time timestamp i.</p><p>Friendship is symmetric. That means if <code>a</code> is friends with <code>b</code>, then <code>b</code> is friends with <code>a</code>. Also, person <code>a</code> is acquainted with a person <code>b</code> if <code>a</code> is friends with <code>b</code>, or <code>a</code> is a friend of someone acquainted with <code>b</code>.</p><p>Return the earliest time for which every person became acquainted with every other person. If there is no such earliest time, return <code>-1</code>.</p></blockquote><h3 id=intuition>Intuition</h3><p>Since the friendship is symetric, wheever two people become friends, we can merge their acquaintance sets togethere. When there is only 1 such sets, everyone is aquainted. For finding earliest time, we simply go through the logs in chronological order.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>earliestAcq</span>(self, logs: List[List[int]], n: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    dsu <span style=color:#f92672>=</span> DSU()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        dsu<span style=color:#f92672>.</span>find(i)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> timestamp, x, y <span style=color:#f92672>in</span> sorted(logs):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> dsu<span style=color:#f92672>.</span>union(x, y):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> dsu<span style=color:#f92672>.</span>components <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> timestamp
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><ul><li>$T(n) = O(n)$ since union is $O(\alpha(n))$. $S(n) = O(n)$</li></ul></div><div class=note id=73c><div style=text-align:right;height:5px><a name=73c href=/notes_collection/lc_notes/73c/ class="xxs grey monospace">73c</a></div><h2 id=making-a-large-island-lc827>Making A Large Island [LC#827]</h2><blockquote><p>You are given an <code>n x n</code> binary matrix grid. You are allowed to change at most one 0 to be 1. Return the size of the largest island in grid after applying this operation. An island is a 4-directionally connected group of 1s.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>First make all islands using same technique in connected components</li><li>Then for each 0, compute largest island you can make by flipping it.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>largest_island</span>(grid: List[List[int]]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    parent <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find</span>(x):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> x <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> parent:
</span></span><span style=display:flex><span>            parent[x], size[x] <span style=color:#f92672>=</span> x, <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> parent[x] <span style=color:#f92672>!=</span> x:
</span></span><span style=display:flex><span>            parent[x] <span style=color:#f92672>=</span> find(parent[x])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> parent[x]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>union</span>(x, y):
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> find(x)
</span></span><span style=display:flex><span>        y <span style=color:#f92672>=</span> find(y)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> x <span style=color:#f92672>!=</span> y:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> size[x] <span style=color:#f92672>&lt;</span> size[y]:
</span></span><span style=display:flex><span>                x, y <span style=color:#f92672>=</span> y, x
</span></span><span style=display:flex><span>            parent[y], size[x] <span style=color:#f92672>=</span> x, size[x] <span style=color:#f92672>+</span> size[y]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    m, n <span style=color:#f92672>=</span> len(grid), len(grid[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(m):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> grid[x][y] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                find((x, y))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> grid[x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][y] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                    union((x, y), (x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> y <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> grid[x][y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                    union((x, y), (x, y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    max_size <span style=color:#f92672>=</span> max(size<span style=color:#f92672>.</span>values(), default<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(m):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> y <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> grid[x][y] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                unique_parents <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> grid[x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][y] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                    unique_parents<span style=color:#f92672>.</span>add(find((x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, y)))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> y <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> grid[x][y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                    unique_parents<span style=color:#f92672>.</span>add(find((x, y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span> grid[x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][y] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                    unique_parents<span style=color:#f92672>.</span>add(find((x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, y)))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> y <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span> grid[x][y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                    unique_parents<span style=color:#f92672>.</span>add(find((x, y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                new_island_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> sum(size[p] <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> unique_parents)
</span></span><span style=display:flex><span>                max_size <span style=color:#f92672>=</span> max(max_size, new_island_size)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_size
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(mn)$</li><li>$S(n) = O(mn)$</li></ul><span class=tag>dsu</span></div><div class=note id=75><div style=text-align:right;height:5px><a name=75 href=/notes_collection/lc_notes/75/ class="xxs grey monospace">75</a></div><h1 id=binary-search>Binary Search</h1><blockquote><p>Minimize k , s.t. condition(k) is True</p></blockquote><pre tabindex=0><code>  [ f ][ f ][ f ][ t ][ t ][ t ][ t ][ t ]     
                   └── ans 
</code></pre><ul><li>Set up the boundary to include all possible elements</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>binary_search</span>(search_space) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> min(search_space), max(search_space)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right <span style=color:#f92672>-</span> left) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> condition(mid):
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> left
</span></span></code></pre></div></div><div class=note id=75a><div style=text-align:right;height:5px><a name=75a href=/notes_collection/lc_notes/75a/ class="xxs grey monospace">75a</a></div><h1 id=binary-search-in-array>Binary Search in Array</h1></div><div class=note id=75a01><div style=text-align:right;height:5px><a name=75a01 href=/notes_collection/lc_notes/75a01/ class="xxs grey monospace">75a01</a></div><h2 id=binary-search-in-a-sorted-array>Binary search in a sorted array</h2><pre tabindex=0><code>  [      &lt;      ][ = ][      &gt;      ]                            
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>binary_search_array</span>(arr: List[int], target: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len(arr) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right <span style=color:#f92672>-</span> left) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> arr[mid] <span style=color:#f92672>&gt;=</span> target:
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> left <span style=color:#66d9ef>if</span> arr[left] <span style=color:#f92672>==</span> target <span style=color:#66d9ef>else</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><span class=tag>binary search</span></div><div class=note id=75a02><div style=text-align:right;height:5px><a name=75a02 href=/notes_collection/lc_notes/75a02/ class="xxs grey monospace">75a02</a></div><h2 id=find-first-and-last-position-of-element-in-sorted-array-lc34>Find First and Last Position of Element in Sorted Array [LC#34]</h2><blockquote><p>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.</p></blockquote><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>searchRange</span>(nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> Tuple[int, int]:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>binary_search</span>(value):
</span></span><span style=display:flex><span>        left, right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len(nums) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>            mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right <span style=color:#f92672>-</span> left) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> nums[mid] <span style=color:#f92672>&gt;=</span> value:
</span></span><span style=display:flex><span>                right <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> left
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    nums<span style=color:#f92672>.</span>append(math<span style=color:#f92672>.</span>inf) <span style=color:#75715e># to handle edge cases</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pos_beg <span style=color:#f92672>=</span> binary_search(target)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> nums[pos_beg] <span style=color:#f92672>!=</span> target:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    pos_end <span style=color:#f92672>=</span> binary_search(target <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (pos_beg, pos_end <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><h3 id=time-complexity>Time Complexity</h3><p>$T(n) = O(\log n)$</p><span class=tag>binary search</span></div><div class=note id=75a03><div style=text-align:right;height:5px><a name=75a03 href=/notes_collection/lc_notes/75a03/ class="xxs grey monospace">75a03</a></div><h2 id=find-minimum-in-rotated-sorted-array-lc153>Find Minimum in Rotated Sorted Array [LC#153]</h2><blockquote><p>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:</p><ul><li>[4,5,6,7,0,1,2] if it was rotated 4 times.</li><li>[0,1,2,4,5,6,7] if it was rotated 7 times.</li></ul><p>Notice that rotating an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>. Given the sorted rotated array nums of unique elements, return the minimum element of this array.</p></blockquote><h3 id=intuition>Intuition</h3><p>minimum number is present in the smallest index <code>k</code> such that <code>nums[k] &lt; nums[-1]</code></p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>findMin</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len(nums) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right <span style=color:#f92672>-</span> left) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> nums[mid] <span style=color:#f92672>&lt;=</span> nums[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> nums[left] 
</span></span></code></pre></div><span class=tag>binary search</span></div><div class=note id=75a04><div style=text-align:right;height:5px><a name=75a04 href=/notes_collection/lc_notes/75a04/ class="xxs grey monospace">75a04</a></div><h2 id=find-peak-element-lc162>Find Peak Element [LC#162]</h2><blockquote><p>A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that <code>nums[-1] = nums[n] = $-\infty$</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time.</p></blockquote><h3 id=intuition>Intuition</h3><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_peak_element</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    lo, hi <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len(nums)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    nums<span style=color:#f92672>.</span>append(<span style=color:#f92672>-</span>math<span style=color:#f92672>.</span>inf)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> lo <span style=color:#f92672>&lt;</span> hi:
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> lo <span style=color:#f92672>+</span> (hi <span style=color:#f92672>-</span> lo)<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> nums[mid] <span style=color:#f92672>&gt;</span> nums[mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>            hi <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            lo <span style=color:#f92672>=</span> mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> lo
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(\log n)$</li><li>$S(n) = O(1)$</li></ul></div><div class=note id=75b><div style=text-align:right;height:5px><a name=75b href=/notes_collection/lc_notes/75b/ class="xxs grey monospace">75b</a></div><h2 id=minimum-limit-of-balls-in-a-bag-lc1760>Minimum Limit of Balls in a Bag [LC#1760]</h2><blockquote><p>You are given an integer array nums where the ith bag contains <code>nums[i]</code> balls. You are also given an integer <code>max_operations</code>. You can perform the following operation at most <code>max_operations</code> times:</p><ul><li>Take any bag of balls and divide it into two new bags with a positive number of balls. For example, a bag of 5 balls can become two new bags of 1 and 4 balls, or two new bags of 2 and 3 balls.</li></ul><p>Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations. Return the minimum possible penalty after performing the operations.</p></blockquote><h3 id=intuition>Intuition</h3><p>Binary search on penalty.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>minimum_size</span>(nums: List[int], max_operations: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>valid</span>(th):
</span></span><span style=display:flex><span>        count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>            operations <span style=color:#f92672>=</span> math<span style=color:#f92672>.</span>ceil(num <span style=color:#f92672>/</span> th) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> operations
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> count <span style=color:#f92672>&gt;</span> max_operations: <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, max(nums)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right <span style=color:#f92672>-</span> left) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> valid(mid):
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> left
</span></span></code></pre></div><h2 id=time-complexity>Time Complexity</h2><p>The search take <code>log(range)</code> steps. The range is of size $2^b$ if $b$ is max number of bits representing the numbers in the list <code>nums</code>. Hence number of search steps is upperbounded by $\log (2^b) = b$. Each step take $O(n)$ to evaluate the validity condition. So time complexity $T(n) = O(b \ast n)$. If we consider $b$ as a constant then time complexity is $O(n)$</p><span class=tag>binary search</span></div><div class=note id=75d><div style=text-align:right;height:5px><a name=75d href=/notes_collection/lc_notes/75d/ class="xxs grey monospace">75d</a></div><h2 id=split-array-largest-sum-lc412>Split Array Largest Sum [LC#412]</h2><blockquote><p>Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum of the split. A subarray is a contiguous part of the array.</p></blockquote><h3 id=intuition>Intuition</h3><p>Binary search on the range of possible values.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>splita_array_largest_sum</span>(nums: List[int], k: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> max(nums), sum(nums)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>valid</span>(th):
</span></span><span style=display:flex><span>        num_partitions <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        sum_partition <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> sum_partition <span style=color:#f92672>+</span> num <span style=color:#f92672>&lt;=</span> th:
</span></span><span style=display:flex><span>                sum_partition <span style=color:#f92672>+=</span> num
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                sum_partition <span style=color:#f92672>=</span> num
</span></span><span style=display:flex><span>                num_partitions <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> num_partitions <span style=color:#f92672>&gt;=</span> k:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right <span style=color:#f92672>-</span> left) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> valid(mid):
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> right
</span></span></code></pre></div><h2 id=time-complexity>Time Complexity</h2><p>The search take <code>log(range)</code> steps. The range is of size $2^b$ if $b$ is max number of bits representing the numbers in the list <code>nums</code>. Hence number of search steps is upperbounded by $\log (2^b) = b$. Each step take $O(n)$ to evaluate the validity condition. So time complexity $T(n) = O(b \ast n)$. If we consider $b$ as a constant then time complexity is $O(n)$</p><span class=tag>binary search</span></div><div class=note id=75e><div style=text-align:right;height:5px><a name=75e href=/notes_collection/lc_notes/75e/ class="xxs grey monospace">75e</a></div><h2 id=swim-in-rising-water-lc778>Swim in Rising Water [LC#778]</h2><blockquote><p>You are given an <code>n x n</code> integer matrix grid where each value <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>. The rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p><p>Return the least time until you can reach the bottom right square <code>(n - 1, n - 1)</code> if you start at the top left square <code>(0, 0)</code>.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Solution is a path from source to target with least maximum elevation.</li><li>Binary search on all possible paths</li><li>BFS or DFS can be used interchangeably</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>swim_in_water</span>(grid: List[List[int]]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    m, n <span style=color:#f92672>=</span> len(grid), len(grid[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>neighbours</span>(x, y):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> dx, dy <span style=color:#f92672>in</span> [(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>), (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>), (<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>), (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)]:
</span></span><span style=display:flex><span>            nx, ny <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> dx, y <span style=color:#f92672>+</span> dy
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> nx <span style=color:#f92672>&lt;</span> m) <span style=color:#f92672>and</span> (<span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> ny <span style=color:#f92672>&lt;</span> n):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>yield</span> (nx, ny)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bfs_with_limit</span>(limit):
</span></span><span style=display:flex><span>        queue <span style=color:#f92672>=</span> deque([(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)])
</span></span><span style=display:flex><span>        seen <span style=color:#f92672>=</span> {(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>            row, col <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (row, col) <span style=color:#f92672>==</span> (m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> nx, ny <span style=color:#f92672>in</span> neighbours(row, col):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (nx, ny) <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> seen <span style=color:#f92672>and</span> grid[nx][ny] <span style=color:#f92672>&lt;=</span> limit:
</span></span><span style=display:flex><span>                    queue<span style=color:#f92672>.</span>append((nx, ny))
</span></span><span style=display:flex><span>                    seen<span style=color:#f92672>.</span>add((nx, ny))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    lo, hi <span style=color:#f92672>=</span> grid[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>], max(max(grid[i]) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(m))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> lo <span style=color:#f92672>&lt;</span> hi:
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> lo <span style=color:#f92672>+</span> (hi <span style=color:#f92672>-</span> lo) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> bfs_with_limit(mid):
</span></span><span style=display:flex><span>            hi <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            lo <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> lo
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(\log(2^b) mn) = O(mn)$</li><li>$S(n) = O(mn)$</li></ul><span class=tag>binary search</span>
<span class=tag>bfs</span></div><div class=note id=80><div style=text-align:right;height:5px><a name=80 href=/notes_collection/lc_notes/80/ class="xxs grey monospace">80</a></div><h1 id=dynamic-programming>Dynamic Programming</h1></div><div class=note id=80a><div style=text-align:right;height:5px><a name=80a href=/notes_collection/lc_notes/80a/ class="xxs grey monospace">80a</a></div><h2 id=target-sum-lc494>Target Sum [LC#494]</h2><blockquote><p>You are given an integer array <code>nums</code> and an integer <code>target</code>. You want to build an expression out of nums by adding one of the symbols <code>+</code> and <code>-</code> before each integer in nums and then concatenate all the integers. For example, if <code>nums = [2, 1]</code>, you can add a <code>+</code> before 2 and a <code>-</code> before 1 and concatenate them to build the expression <code>"+2-1"</code>.
Return the number of different expressions that you can build, which evaluates to target.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Dynamic Programming</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_expressions</span>(nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@cache</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>memo</span>(target, i):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> target <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        for_plus <span style=color:#f92672>=</span> <span style=color:#f92672>+</span>nums[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> target
</span></span><span style=display:flex><span>        for_minus <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>nums[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> target
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> memo(for_plus, i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> memo(for_minus, i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> memo(target, n)
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(nW)$, $W = target$</li><li>$S(n) = O(nW)$, but can be optimised to $O(W)$</li></ul><span class=tag>dp</span></div><div class=note id=80b><div style=text-align:right;height:5px><a name=80b href=/notes_collection/lc_notes/80b/ class="xxs grey monospace">80b</a></div><h2 id=edit-distance-lc72>Edit Distance [LC#72]</h2><blockquote><p>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word:</p><ul><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ul></blockquote><h3 id=intuition>Intuition</h3><p>Let <code>cost[i][j]</code> is the minimum edit distance (or the minimum number of operations) required to transform the first <code>i</code> characters of word1 into the first <code>j</code> characters of word2.</p><p><strong>Dynamic Programming</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>edit_distance</span>(word1: str, word2: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Define the costs for operations</span>
</span></span><span style=display:flex><span>    costs <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;insert&#39;</span>: <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;delete&#39;</span>: <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;substitute&#39;</span>: <span style=color:#ae81ff>1</span>}
</span></span><span style=display:flex><span>    m, n <span style=color:#f92672>=</span> len(word1), len(word2)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    cost <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Initialize the first row and column</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#75715e># Cost of deleting all characters from word1 to form word2</span>
</span></span><span style=display:flex><span>        cost[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> i  <span style=color:#f92672>*</span> costs[<span style=color:#e6db74>&#39;delete&#39;</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#75715e># Cost of inserting all characters to word1 to form word2</span>
</span></span><span style=display:flex><span>        cost[<span style=color:#ae81ff>0</span>][j] <span style=color:#f92672>=</span> j  <span style=color:#f92672>*</span> costs[<span style=color:#e6db74>&#39;insert&#39;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Fill the cost matrix</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> word1[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> word2[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>                cost[i][j] <span style=color:#f92672>=</span> cost[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]  <span style=color:#75715e># No operation needed</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                cost[i][j] <span style=color:#f92672>=</span> min(
</span></span><span style=display:flex><span>                    cost[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>+</span> costs[<span style=color:#e6db74>&#39;insert&#39;</span>],      <span style=color:#75715e># Insert</span>
</span></span><span style=display:flex><span>                    cost[i][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> costs[<span style=color:#e6db74>&#39;delete&#39;</span>],      <span style=color:#75715e># Delete</span>
</span></span><span style=display:flex><span>                    cost[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> costs[<span style=color:#e6db74>&#39;substitute&#39;</span>]  <span style=color:#75715e># Substitute</span>
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cost[m][n]
</span></span></code></pre></div><ul><li>$T(n) = O(mn)$</li><li>$S(n) = O(mn)$ but can be optimised to $O(\min(m,n))$</li></ul><span class=tag>string</span>
<span class=tag>dp</span></div><div class=note id=80c><div style=text-align:right;height:5px><a name=80c href=/notes_collection/lc_notes/80c/ class="xxs grey monospace">80c</a></div><h2 id=interleaving-string-lc97>Interleaving String [LC#97]</h2><blockquote><p>Given strings <code>u</code>, <code>v</code>, and <code>t</code>, find whether <code>t</code> can formed by an interleaving of <code>u</code> and <code>v</code>.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>Dynamic Prgraming</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> functools <span style=color:#f92672>import</span> cache
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>isInterleave</span>(u: str, v: str, t: str) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    m, n, k <span style=color:#f92672>=</span> len(u), len(v), len(t)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> m <span style=color:#f92672>+</span> n <span style=color:#f92672>!=</span> t: <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@cache</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>memo</span>(i, j, k):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> j <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> u[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> t[k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>and</span> memo(i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, j, k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> j <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> v[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> t[k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>and</span> memo(i, j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> memo(m, n, k)
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(mn)$</li><li>$S(n) = O(mn)$ but optimised to $O(\min\{m,n\})$</li></ul><span class=tag>string</span>
<span class=tag>dp</span></div><div class=note id=80d><div style=text-align:right;height:5px><a name=80d href=/notes_collection/lc_notes/80d/ class="xxs grey monospace">80d</a></div><h2 id=distinct-subsequences-lc115>Distinct Subsequences [LC#115]</h2><blockquote><p>Given two strings <code>s</code> and <code>t</code>, return the number of distinct subsequences of <code>s</code> which equals <code>t</code>.</p></blockquote><h3 id=intuition>Intuition</h3><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_distinct_subsequences</span>(s: str, t: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> len(s) 
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(t)
</span></span><span style=display:flex><span>    dp <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    dp[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        dp[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            dp[i][j] <span style=color:#f92672>=</span> dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> s[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> t[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>                dp[i][j] <span style=color:#f92672>+=</span> dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dp[m][n]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_distinct_subsequences_space_optimised</span>(s: str, t: str) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> len(s)  
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(t)  
</span></span><span style=display:flex><span>    dp <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>: [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>), <span style=color:#ae81ff>1</span>:[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    dp[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        dp[i<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            dp[i<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j] <span style=color:#f92672>=</span> dp[(i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> s[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> t[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>                dp[i<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j] <span style=color:#f92672>+=</span> dp[(i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dp[m<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][n]
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(mn)$</li><li>$S(n) = O(mn)$ but optimised to $O(\min\{m,n\})$</li></ul><span class=tag>string</span>
<span class=tag>sub sequence</span>
<span class=tag>dp</span></div><div class=note id=84><div style=text-align:right;height:5px><a name=84 href=/notes_collection/lc_notes/84/ class="xxs grey monospace">84</a></div><h1 id=greedy-approaches>Greedy Approaches</h1></div><div class=note id=84a01><div style=text-align:right;height:5px><a name=84a01 href=/notes_collection/lc_notes/84a01/ class="xxs grey monospace">84a01</a></div><h2 id=gas-station-lc134>Gas Station [LC#134]</h2><blockquote><p>There are n gas stations along a circular route, where the amount of gas at the <code>station i</code> is <code>gas[i]</code>. You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the station <code>i</code> station to <code>(i + 1)</code>. You begin the journey with an empty tank at one of the gas stations.</p><p>Given two integer arrays gas and cost, return the starting gas station&rsquo;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.</p></blockquote><h3 id=intuition-greedy-approach>Intuition: Greedy Approach</h3><ul><li>Base case: If the total gas is less than the total cost, the circuit is not traversable. Otherwise, there is at least one valid starting point.</li><li>If we had <code>tank</code> amount of gas before entering station <code>i</code> we can update the state as <code>tank += (gas[i] - cost[i])</code>. If we are starting from <code>i</code>, we set <code>tank = 0</code>.</li><li>We started from j and <code>tank</code> becomes negative at i, the segment [j,i] is not traversable starting with an empty tank. Additionally, none of the stations in that segment can be valid starting points as that would also lead to a negative <code>tank</code>.</li><li>Therefore, the possible starting point is <code>i + 1</code>, and reset <code>tank</code> to 0 and re-check.</li><li>We are guranteed to find a starting point.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gas_station_valid_starting_point</span>(gas: List[int], cost: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> sum(gas) <span style=color:#f92672>&lt;</span> sum(cost):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    tank <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    starting_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(gas)):
</span></span><span style=display:flex><span>        tank <span style=color:#f92672>+=</span> gas[i] <span style=color:#f92672>-</span> cost[i]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> tank <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            tank <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            starting_index <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> starting_index
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$ , $S(n) = O(1)$</li></ul><span class=tag>greedy</span></div><div class=note id=84a02><div style=text-align:right;height:5px><a name=84a02 href=/notes_collection/lc_notes/84a02/ class="xxs grey monospace">84a02</a></div><h2 id=max-chunks-to-make-sorted-lc769>Max Chunks To Make Sorted [LC#769]</h2><blockquote><p>You are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1]. We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array. Return the largest number of chunks we can make to sort the array.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>If we encounter a number k at position i, then $[i, k]$ should be in same chunk for the array to get sorted.</li><li>So we traverse the array left to right and keep expanding the chunk&rsquo;s right limit as we encounter new number.</li><li>When we are a number and chunk&rsquo;s limit cannot be expanded beyond the same position, we can start a new chunk.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>maximum_chunks</span>(arr: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    right_limit <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, num <span style=color:#f92672>in</span> enumerate(arr):
</span></span><span style=display:flex><span>        right_limit <span style=color:#f92672>=</span> max(right_limit, num)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&gt;=</span> right_limit:
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>           
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> count
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$</li></ul><span class=tag>greedy</span></div><div class=note id=84a03><div style=text-align:right;height:5px><a name=84a03 href=/notes_collection/lc_notes/84a03/ class="xxs grey monospace">84a03</a></div><h2 id=jump-game-lc55>Jump Game [LC#55]</h2><blockquote><p>You are given an integer array nums. You are initially positioned at the array&rsquo;s first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.</p></blockquote><h3 id=intuition>Intuition</h3><p>There is a dp approach. But time complexity is $O(n^2)$ with linear storage. The greedy approach.</p><ul><li>We keep track of the positions from which last index is reachable. In the begning its the last index itself.</li><li>traverse the array in the reverse order. If we can reach on of the exisiting reachable position from current index, then the curent index is also in reachable.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>jump_game</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>    left_limit <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> pos <span style=color:#f92672>in</span> range(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> pos <span style=color:#f92672>+</span> nums[pos] <span style=color:#f92672>&gt;=</span> left_limit:
</span></span><span style=display:flex><span>            left_limit <span style=color:#f92672>=</span> pos
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> left_limit <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$</li></ul><span class=tag>greedy</span></div><div class=note id=84a03a><div style=text-align:right;height:5px><a name=84a03a href=/notes_collection/lc_notes/84a03a/ class="xxs grey monospace">84a03a</a></div><h2 id=jump-game-ii-lc45>Jump Game II [LC#45]</h2><blockquote><p>You are given a 0-indexed array of integers <code>nums</code> of length n. You are initially positioned at <code>nums[0]</code>. Each element <code>nums[i]</code> represents the maximum length of a forward jump from index <code>i</code>. Return the minimum number of jumps to reach the last position.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li><p>There is a DP approach which takes $O(n^2)$ <code>steps[i] = 1+min(steps[j], 0&lt;=j&lt;i)</code></p></li><li><p>Say we are at a position left and max reachable range is till right.</p></li><li><p>By using a node in this range, we can extend this reachable range by adding another jump.</p></li><li><p>The extended range is <code>max(nums[i]+i for i in [left, right])</code></p></li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>min_jump</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>: <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    left, right, jumps <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> right <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        max_reach <span style=color:#f92672>=</span> max(nums[i] <span style=color:#f92672>+</span> i <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(left, right <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>        left <span style=color:#f92672>=</span> right 
</span></span><span style=display:flex><span>        right <span style=color:#f92672>=</span> max_reach
</span></span><span style=display:flex><span>        jumps <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> jumps
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$</li></ul><span class=tag>greedy</span></div><div class=note id=84a03b><div style=text-align:right;height:5px><a name=84a03b href=/notes_collection/lc_notes/84a03b/ class="xxs grey monospace">84a03b</a></div><h2 id=jump-game-iii-lc1306>Jump Game III [LC#1306]</h2><blockquote><p>Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index <code>i</code>, you can jump to <code>i + arr[i]</code> or <code>i - arr[i]</code>, check if you can reach any index with value 0. Notice that you can not jump outside of the array at any time.</p></blockquote><h3 id=intuition>Intuition</h3><ul><li>BFS</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>jump</span>(arr: List[int], start: int) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    seen <span style=color:#f92672>=</span> set([start])
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque([start])
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(arr)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> arr[node]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>: <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> idx <span style=color:#f92672>in</span> [node<span style=color:#f92672>+</span>arr[node],  node<span style=color:#f92672>-</span>arr[node]]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> idx <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> seen <span style=color:#f92672>and</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> idx <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append(idx)
</span></span><span style=display:flex><span>                seen<span style=color:#f92672>.</span>add(idx)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(n)$. We can use original array to maintain seen nodes by making them negative.</li></ul><span class=tag>bfs</span></div><div class=note id=84a04><div style=text-align:right;height:5px><a name=84a04 href=/notes_collection/lc_notes/84a04/ class="xxs grey monospace">84a04</a></div><h2 id=maximum-swap-lc670>Maximum Swap [LC#670]</h2><blockquote><p>You are given an integer num. You can swap two digits at most once to get the maximum valued number. Return the maximum valued number you can get.</p></blockquote><h3 id=intuition>Intuition</h3><p>The possible pairs which can be swapped to increase the value of the numbers are such that larger number follows smaller number. The optimum pair among those are the ones where the larger number is most to the left.</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>maximum_swap</span>(num: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    digits <span style=color:#f92672>=</span> list(str(num))
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(digits)
</span></span><span style=display:flex><span>    max_pos <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> n, n
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> digits[i] <span style=color:#f92672>&gt;</span> digits[max_pos]:
</span></span><span style=display:flex><span>            max_pos <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> digits[i] <span style=color:#f92672>&lt;</span> digits[max_pos]:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> max_pos
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> left <span style=color:#f92672>==</span> n <span style=color:#f92672>or</span> right <span style=color:#f92672>==</span> n:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> num
</span></span><span style=display:flex><span>    digits[left], digits[right] <span style=color:#f92672>=</span> digits[right], digits[left]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(<span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(digits))
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$</li></ul></div><div class=note id=85><div style=text-align:right;height:5px><a name=85 href=/notes_collection/lc_notes/85/ class="xxs grey monospace">85</a></div><h1 id=backtracking>Backtracking</h1><p>Code template</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>ans <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>backtrack</span>(state):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_valid(state):
</span></span><span style=display:flex><span>        ans<span style=color:#f92672>.</span>append(state)
</span></span><span style=display:flex><span>        <span style=color:#75715e># return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> candidate <span style=color:#f92672>in</span> get_candidates(state):
</span></span><span style=display:flex><span>        new_state <span style=color:#f92672>=</span> state <span style=color:#f92672>+</span> candidate
</span></span><span style=display:flex><span>        backtrack(new_state)
</span></span></code></pre></div></div><div class=note id=85a><div style=text-align:right;height:5px><a name=85a href=/notes_collection/lc_notes/85a/ class="xxs grey monospace">85a</a></div><h2 id=n-queens-problem>N-Queens Problem</h2><blockquote><p>The n-queens puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other. Given an integer <code>n</code>, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.</p><p>Each solution contains a distinct board configuration of the n-queens&rsquo; placement, where &lsquo;Q&rsquo; and &lsquo;.&rsquo; both indicate a queen and an empty space, respectively.</p></blockquote><h3 id=intuition>Intuition</h3><p>All indices of same diagonal share the same value for <code>(x-y)</code>. Similarly, all indices of anti diagonal share the same value for <code>(x+y)</code>.</p><p><strong>Backtracking</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>n_queens</span>(n: int) <span style=color:#f92672>-&gt;</span> List[List[str]]:
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    state <span style=color:#f92672>=</span> [[<span style=color:#e6db74>&#34;.&#34;</span>] <span style=color:#f92672>*</span> n <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n)]
</span></span><span style=display:flex><span>    m_row <span style=color:#f92672>=</span> defaultdict(int)
</span></span><span style=display:flex><span>    m_col <span style=color:#f92672>=</span> defaultdict(int)
</span></span><span style=display:flex><span>    m_diag <span style=color:#f92672>=</span> defaultdict(int)
</span></span><span style=display:flex><span>    m_antidiag <span style=color:#f92672>=</span> defaultdict(int)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>mark</span>(x, y, V<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        m_row[x] <span style=color:#f92672>+=</span> V
</span></span><span style=display:flex><span>        m_col[y] <span style=color:#f92672>+=</span> V
</span></span><span style=display:flex><span>        m_diag[x <span style=color:#f92672>-</span> y] <span style=color:#f92672>+=</span> V
</span></span><span style=display:flex><span>        m_antidiag[x <span style=color:#f92672>+</span> y] <span style=color:#f92672>+=</span> V
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_mark</span>(x, y):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> m_row[x] <span style=color:#f92672>+</span> m_col[y] <span style=color:#f92672>+</span> m_diag[x <span style=color:#f92672>-</span> y] <span style=color:#f92672>+</span> m_antidiag[x <span style=color:#f92672>+</span> y]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>backtrack</span>(row):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> row <span style=color:#f92672>==</span> n:
</span></span><span style=display:flex><span>            ans<span style=color:#f92672>.</span>append([<span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(c) <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> state])
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> get_mark(row, col) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e># keep queen</span>
</span></span><span style=display:flex><span>                mark(row, col, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                state[row][col] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Q&#34;</span>
</span></span><span style=display:flex><span>                backtrack(row <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># remove queen</span>
</span></span><span style=display:flex><span>                state[row][col] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;.&#34;</span>
</span></span><span style=display:flex><span>                mark(row, col, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    backtrack(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans
</span></span></code></pre></div></div><div class=note id=85b><div style=text-align:right;height:5px><a name=85b href=/notes_collection/lc_notes/85b/ class="xxs grey monospace">85b</a></div><h2 id=sudoku-solver-lc37>Sudoku Solver [LC#37]</h2><blockquote><p>Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules:</p><ol><li>Each of the digits 1-9 must occur exactly once in each row.</li><li>Each of the digits 1-9 must occur exactly once in each column.</li><li>Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
The &lsquo;.&rsquo; character indicates empty cells.</li></ol></blockquote><h3 id=intuition>Intuition</h3><p>Backtracking</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>solve_sudoku</span>(board: List[List[str]]) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>    positions <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>9</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>9</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> board[i][j] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;.&#34;</span>:
</span></span><span style=display:flex><span>                positions<span style=color:#f92672>.</span>append((i, j))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_possible_numbers</span>(x, y):
</span></span><span style=display:flex><span>        possible_numbers <span style=color:#f92672>=</span> set([<span style=color:#e6db74>&#34;1&#34;</span>, <span style=color:#e6db74>&#34;2&#34;</span>, <span style=color:#e6db74>&#34;3&#34;</span>, <span style=color:#e6db74>&#34;4&#34;</span>, <span style=color:#e6db74>&#34;5&#34;</span>, <span style=color:#e6db74>&#34;6&#34;</span>, <span style=color:#e6db74>&#34;7&#34;</span>, <span style=color:#e6db74>&#34;8&#34;</span>, <span style=color:#e6db74>&#34;9&#34;</span>])
</span></span><span style=display:flex><span>        cross <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>9</span>):
</span></span><span style=display:flex><span>            cross<span style=color:#f92672>.</span>add(board[x][i])
</span></span><span style=display:flex><span>            cross<span style=color:#f92672>.</span>add(board[i][y])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range((x <span style=color:#f92672>//</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>, (x <span style=color:#f92672>//</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range((y <span style=color:#f92672>//</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>, (y <span style=color:#f92672>//</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>):
</span></span><span style=display:flex><span>                cross<span style=color:#f92672>.</span>add(board[i][j])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> possible_numbers<span style=color:#f92672>.</span>difference(cross)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>backtrack</span>(i):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&gt;=</span> len(positions):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        x, y <span style=color:#f92672>=</span> positions[i]
</span></span><span style=display:flex><span>        possible_numbers <span style=color:#f92672>=</span> get_possible_numbers(x, y)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> possible_numbers:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> possible_numbers:
</span></span><span style=display:flex><span>            board[x][y] <span style=color:#f92672>=</span> num
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> backtrack(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        board[x][y] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;.&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    backtrack(<span style=color:#ae81ff>0</span>)
</span></span></code></pre></div></div><div class=note id=87><div style=text-align:right;height:5px><a name=87 href=/notes_collection/lc_notes/87/ class="xxs grey monospace">87</a></div><h1 id=knapsack>Knapsack</h1></div><div class=note id=87a><div style=text-align:right;height:5px><a name=87a href=/notes_collection/lc_notes/87a/ class="xxs grey monospace">87a</a></div><h2 id=bounded-knapsack>Bounded Knapsack</h2><p>Bounded knapsack is when we have $n$ items $[(w_i, v_i, n_i)]$ representing weight, value and copies available of each item. This is tribvially reducible to 0/1 knapsack if we simply assume that there are $n_i$ number of distinct items with same weight and value for each of the original item. The time complexity would then be $O(sum(n_i)\times sum(w_i n_i))$.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>knapsack_01</span>(weights: List[int], values: List[int], capacity: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    max_value <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (capacity <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> weight, value <span style=color:#f92672>in</span> zip(weights, values):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> slack <span style=color:#f92672>in</span> range(capacity, weight <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            max_value[slack] <span style=color:#f92672>=</span> max(
</span></span><span style=display:flex><span>                max_value[slack], 
</span></span><span style=display:flex><span>                max_value[slack <span style=color:#f92672>-</span> weight] <span style=color:#f92672>+</span> value
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_value[capacity]
</span></span></code></pre></div><p>There is a slightly better way to do the reduction. create logaritmic number of copies of items with 1,2,4,.. times weight, value of each item and solve as a 0/1 knapsack problem. Any number of selection of copies of original problem can be represented by a specific selection of new items. Time complexity is $O(sum(w_i) \times n \times \log (\max n_i))$. <a href=https://blog.mitrichev.ch/2011/07/integral-bounded-knapsack-problem.html>Ref</a></p></div><div class=note id=87b><div style=text-align:right;height:5px><a name=87b href=/notes_collection/lc_notes/87b/ class="xxs grey monospace">87b</a></div><h2 id=unbounded-knapsack>Unbounded Knapsack</h2><p>Unbounded knpasack is when we have infinite number of each items.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>unbounded_knapsack</span>(weights: List[int], values: List[int], capacity: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    max_value <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (capacity <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, capacity <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(len(weights)):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> weights[j] <span style=color:#f92672>&lt;=</span> i:
</span></span><span style=display:flex><span>                max_value[i] <span style=color:#f92672>=</span> max(
</span></span><span style=display:flex><span>                    max_value[i], 
</span></span><span style=display:flex><span>                    max_value[i <span style=color:#f92672>-</span> weights[j]] <span style=color:#f92672>+</span> values[j]
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_value[capacity]
</span></span></code></pre></div></div><div class=note id=87c><div style=text-align:right;height:5px><a name=87c href=/notes_collection/lc_notes/87c/ class="xxs grey monospace">87c</a></div><h2 id=fractional-knapsack>Fractional Knapsack</h2></div><div class=note id=87d><div style=text-align:right;height:5px><a name=87d href=/notes_collection/lc_notes/87d/ class="xxs grey monospace">87d</a></div><h2 id=reducing-subset-sum-to-01-knapsack>Reducing subset sum to 0/1 knapsack</h2><h3 id=intuition>Intuition</h3><p>The Subset Sum problem can be reduced to the 0/1 Knapsack problem by treating the elements of the set as both the weights and values of the items. Given a target sum, we can construct a 0/1 Knapsack with target sum as the capacity and if the the maximum value of the knapsack is equal to the target sum, the selected items form the required subset.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>subset_sum</span>(nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    max_value <span style=color:#f92672>=</span> knapsack_01(nums, nums, target)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_value <span style=color:#f92672>==</span> target
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>knapsack_01</span>(weights: List[int], values: List[int], capacity: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    max_value <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> (capacity <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> weight, value <span style=color:#f92672>in</span> zip(weights, values):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> slack <span style=color:#f92672>in</span> range(capacity, weight <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            max_value[slack] <span style=color:#f92672>=</span> max(max_value[slack], max_value[slack <span style=color:#f92672>-</span> weight] <span style=color:#f92672>+</span> value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max_value[capacity]
</span></span></code></pre></div></div><div class=note id=87e><div style=text-align:right;height:5px><a name=87e href=/notes_collection/lc_notes/87e/ class="xxs grey monospace">87e</a></div><h2 id=coin-change>Coin Change</h2></div><div class=note id=87e01><div style=text-align:right;height:5px><a name=87e01 href=/notes_collection/lc_notes/87e01/ class="xxs grey monospace">87e01</a></div><h2 id=coin-change-lc322>Coin Change [LC#322]</h2><blockquote><p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.</p></blockquote><h3 id=intuition>Intuition</h3><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>coin_change</span>(coins: List[int], amount: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    dp <span style=color:#f92672>=</span> [float(<span style=color:#e6db74>&#39;inf&#39;</span>)] <span style=color:#f92672>*</span> (amount <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    dp[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> coin <span style=color:#f92672>in</span> coins:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(coin, amount <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            dp[x] <span style=color:#f92672>=</span> min(dp[x], dp[x <span style=color:#f92672>-</span> coin] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dp[amount] <span style=color:#66d9ef>if</span> dp[amount] <span style=color:#f92672>!=</span> float(<span style=color:#e6db74>&#39;inf&#39;</span>) <span style=color:#66d9ef>else</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> 
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(nW)$</li><li>$S(n) = O(W)$</li></ul><span class=tag>knapsack</span></div><div class=note id=87e02><div style=text-align:right;height:5px><a name=87e02 href=/notes_collection/lc_notes/87e02/ class="xxs grey monospace">87e02</a></div><h2 id=coin-change-ii-lc518>Coin Change II [LC#518]</h2><blockquote><p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money. Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0. You may assume that you have an infinite number of each kind of coin.</p></blockquote><h3 id=intuition>Intuition</h3><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>coin_change</span>(amount: int, coins: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    dp <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span>(amount <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    dp[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> coin <span style=color:#f92672>in</span> coins:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> amt <span style=color:#f92672>in</span> range(coin, amount <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            dp[amt] <span style=color:#f92672>+=</span> dp[amt <span style=color:#f92672>-</span> coin]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dp[amount]
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(nW)$</li><li>$S(n) = O(n)$</li></ul><span class=tag>knapsack</span></div><div class=note id=90><div style=text-align:right;height:5px><a name=90 href=/notes_collection/lc_notes/90/ class="xxs grey monospace">90</a></div><h1 id=range-queries>Range Queries</h1><ul><li>Offline Range queries</li><li>Online Range queries</li></ul></div><div class=note id=90a><div style=text-align:right;height:5px><a name=90a href=/notes_collection/lc_notes/90a/ class="xxs grey monospace">90a</a></div><h3 id=fenwick-trees-or-binary-indexed-tree>Fenwick Trees or Binary Indexed Tree</h3><ul><li>Each index in the fenwick tree is responsible for a rnage of values in the original array.</li><li>Requires $O(n)$ storage.</li><li>Can calculate prefix sums in $O(\log n)$ time.</li><li>Point updates can also be performed in $O(\log n)$</li><li>Can only do operations which are invertible.</li></ul><p>References</p><ul><li><a href=https://cp-algorithms.com/data_structures/fenwick.html>https://cp-algorithms.com/data_structures/fenwick.html</a></li><li><a href="https://www.youtube.com/watch?v=uSFzHCZ4E-8">https://www.youtube.com/watch?v=uSFzHCZ4E-8</a></li><li><a href=https://blog.kartynnik.info/posts/fenwick-trees-are-nothing-but>https://blog.kartynnik.info/posts/fenwick-trees-are-nothing-but</a></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>          0· 1· 2· 3· 4· 5· 6· 7· 8· 9·10·11·12·13·14·15
</span></span><span style=display:flex><span>    A = [  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>T[ 0] = [ ✚|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ]
</span></span><span style=display:flex><span>T[ 1] = [ ✚| ✚|  |  |  |  |  |  |  |  |  |  |  |  |  |  ]
</span></span><span style=display:flex><span>T[ 2] = [  |  | ✚|  |  |  |  |  |  |  |  |  |  |  |  |  ]
</span></span><span style=display:flex><span>T[ 3] = [ ✚| ✚| ✚| ✚|  |  |  |  |  |  |  |  |  |  |  |  ]
</span></span><span style=display:flex><span>T[ 4] = [  |  |  |  | ✚|  |  |  |  |  |  |  |  |  |  |  ]
</span></span><span style=display:flex><span>T[ 5] = [  |  |  |  | ✚| ✚|  |  |  |  |  |  |  |  |  |  ]
</span></span><span style=display:flex><span>T[ 6] = [  |  |  |  |  |  | ✚|  |  |  |  |  |  |  |  |  ]
</span></span><span style=display:flex><span>T[ 7] = [ ✚| ✚| ✚| ✚| ✚| ✚| ✚| ✚|  |  |  |  |  |  |  |  ]
</span></span><span style=display:flex><span>T[ 8] = [  |  |  |  |  |  |  |  | ✚|  |  |  |  |  |  |  ]
</span></span><span style=display:flex><span>T[ 9] = [  |  |  |  |  |  |  |  | ✚| ✚|  |  |  |  |  |  ]
</span></span><span style=display:flex><span>T[10] = [  |  |  |  |  |  |  |  |  |  | ✚|  |  |  |  |  ]
</span></span><span style=display:flex><span>T[11] = [  |  |  |  |  |  |  |  | ✚| ✚| ✚| ✚|  |  |  |  ]
</span></span><span style=display:flex><span>T[12] = [  |  |  |  |  |  |  |  |  |  |  |  | ✚|  |  |  ]
</span></span><span style=display:flex><span>T[13] = [  |  |  |  |  |  |  |  |  |  |  |  | ✚| ✚|  |  ]
</span></span><span style=display:flex><span>T[14] = [  |  |  |  |  |  |  |  |  |  |  |  |  |  | ✚|  ]
</span></span><span style=display:flex><span>T[15] = [ ✚| ✚| ✚| ✚| ✚| ✚| ✚| ✚| ✚| ✚| ✚| ✚| ✚| ✚| ✚| ✚]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>OP <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> a, b: a<span style=color:#f92672>+</span>b
</span></span><span style=display:flex><span>OP_INV <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> a, b: a <span style=color:#f92672>-</span> b
</span></span><span style=display:flex><span>E <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> : <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FenwickTree</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, A: List[int]):
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(A)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>T <span style=color:#f92672>=</span> A<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            parent <span style=color:#f92672>=</span> i <span style=color:#f92672>|</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> parent <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>T[parent] <span style=color:#f92672>+=</span> self<span style=color:#f92672>.</span>T[i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, i, delta):
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(self<span style=color:#f92672>.</span>T)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>T[i] <span style=color:#f92672>=</span> OP(self<span style=color:#f92672>.</span>T[i], delta)
</span></span><span style=display:flex><span>            i <span style=color:#f92672>=</span> i <span style=color:#f92672>|</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>prefix_sum</span>(self, i): <span style=color:#75715e># sum [0, i]</span>
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> E()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            res <span style=color:#f92672>=</span> OP(result, self<span style=color:#f92672>.</span>T[i])
</span></span><span style=display:flex><span>            i <span style=color:#f92672>=</span> (i <span style=color:#f92672>&amp;</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>range_sum</span>(self, l, r):  <span style=color:#75715e># sum [l, r)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> OP_INV(self<span style=color:#f92672>.</span>prefix_sum(r <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) ,  self<span style=color:#f92672>.</span>prefix_sum(l <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__getitem__</span>(self, idx: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>sum_range(idx, idx)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>append</span>(self, val):
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(self<span style=color:#f92672>.</span>T)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>T<span style=color:#f92672>.</span>append(E())
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>add(n, val)
</span></span></code></pre></div><span class=tag>fenwick trees</span>
<span class=tag>prefix sum</span>
<span class=tag>rmq</span></div><div class=note id=90b><div style=text-align:right;height:5px><a name=90b href=/notes_collection/lc_notes/90b/ class="xxs grey monospace">90b</a></div><h3 id=segment-trees>Segment Trees</h3><ul><li>Segment Trees are a data structure where each node is responsible for a range of values.</li><li>Can do point updates in $O(\log n)$ and range queries in $O(\log n)$.</li><li>Requires $2\cdot n+1$ storage.</li><li>Implemented as a collection of complete binary tree.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>┌───────────────────────────────────────────────────────────────┐
</span></span><span style=display:flex><span>│                               1:                              │     
</span></span><span style=display:flex><span>│                             -----                             │
</span></span><span style=display:flex><span>╔═══════════════════════════════╗───────────────────────────────┤
</span></span><span style=display:flex><span>║               2:              ║               3:              │     
</span></span><span style=display:flex><span>║             [3,11)            ║             -----             │
</span></span><span style=display:flex><span>╟───────────────┬───────────────╫───────────────╔═══════════════╗
</span></span><span style=display:flex><span>║       4:      │       5:      ║       6:      ║       7:      ║
</span></span><span style=display:flex><span>║     [3,7)     │     [7,11)    ║     -----     ║     [1,3)     ║
</span></span><span style=display:flex><span>╟───────┬───────┼───────┬───────╠═══════╦═══════╣───────┬───────╢
</span></span><span style=display:flex><span>║   8:  │   9:  │  10:  │  11:  ║  12:  ║  13:  ║  14:  │  15:  ║
</span></span><span style=display:flex><span>║ [3,5) │ [5,7) │ [7,9) │ [9,11)║[11,13)║   0   ║   1   │   2   ║
</span></span><span style=display:flex><span>╟───┬───┼───┬───┼───┬───┼───┬───╫───┬───╠═══╤═══╩═══╤═══╪═══╤═══╝
</span></span><span style=display:flex><span>║16:│17:│18:│19:│20:│21:│22:│23:║24:│25:║   │   │   │   │   │   |
</span></span><span style=display:flex><span>║ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 ║11 │12 ║   │   │   │   │   │   │
</span></span><span style=display:flex><span>╚═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╩═══╧═══╝───┴───┴───┴───┴───┴───┘
</span></span><span style=display:flex><span>┌─────────┐
</span></span><span style=display:flex><span>│Tree idx:│
</span></span><span style=display:flex><span>│  range  │
</span></span><span style=display:flex><span>└─────────┘
</span></span></code></pre></div><p>References</p><ul><li><a href=https://codeforces.com/blog/entry/18051>https://codeforces.com/blog/entry/18051</a></li><li><a href="https://www.youtube.com/watch?v=xztU7lmDLv8">https://www.youtube.com/watch?v=xztU7lmDLv8</a></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>OP <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> a, b: min(a, b)
</span></span><span style=display:flex><span>E <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> : math<span style=color:#f92672>.</span>inf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SegTree</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, A: List[int]) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(A)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>T: List[int] <span style=color:#f92672>=</span> [E()] <span style=color:#f92672>*</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> n)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>T[n <span style=color:#f92672>+</span> i] <span style=color:#f92672>=</span> A[i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>T[i] <span style=color:#f92672>=</span> OP(self<span style=color:#f92672>.</span>T[<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i] , self<span style=color:#f92672>.</span>T[<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>n: int <span style=color:#f92672>=</span> n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__getitem__</span>(self, i: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>T[self<span style=color:#f92672>.</span>n <span style=color:#f92672>+</span> i]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>point_update</span>(self, i: int, value: int) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        i <span style=color:#f92672>+=</span> self<span style=color:#f92672>.</span>n
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>T[i] <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            i <span style=color:#f92672>//=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>T[i] <span style=color:#f92672>=</span> OP(self<span style=color:#f92672>.</span>T[<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i] , self<span style=color:#f92672>.</span>T[<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>range_query</span>(self, l: int, r: int) <span style=color:#f92672>-&gt;</span> int: <span style=color:#75715e># [l, r)</span>
</span></span><span style=display:flex><span>        res_l, res_r <span style=color:#f92672>=</span> E(), E()
</span></span><span style=display:flex><span>        l <span style=color:#f92672>+=</span> self<span style=color:#f92672>.</span>n
</span></span><span style=display:flex><span>        r <span style=color:#f92672>+=</span> self<span style=color:#f92672>.</span>n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> l <span style=color:#f92672>&lt;</span> r:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> l <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                res_l <span style=color:#f92672>=</span> OP(res_l, self<span style=color:#f92672>.</span>T[l])
</span></span><span style=display:flex><span>                l <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> r <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                r <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                res_r <span style=color:#f92672>=</span> OP(self<span style=color:#f92672>.</span>T[r], res_r)
</span></span><span style=display:flex><span>            l <span style=color:#f92672>//=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>            r <span style=color:#f92672>//=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> OP(res_l, res_r)
</span></span></code></pre></div><span class=tag>segment trees</span>
<span class=tag>rmq</span></div><div class=note id=90c01><div style=text-align:right;height:5px><a name=90c01 href=/notes_collection/lc_notes/90c01/ class="xxs grey monospace">90c01</a></div><h2 id=range-frequency-queries-lc2080>Range Frequency Queries [LC#2080]</h2><blockquote><p>Design a data structure to find the frequency of a given value in a given subarray. The frequency of a value in a subarray is the number of occurrences of that value in the subarray.</p><p>Implement the RangeFreqQuery class: RangeFreqQuery(int[] arr) Constructs an instance of the class with the given 0-indexed integer array arr. int query(int left, int right, int value) Returns the frequency of value in the subarray arr[left&mldr;right]. A subarray is a contiguous sequence of elements within an array. arr[left&mldr;right] denotes the subarray that contains the elements of nums between indices left and right (inclusive).</p></blockquote><h3 id=intuition>Intuition</h3><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RangeFreqQuery</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, arr: List[int]):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>index <span style=color:#f92672>=</span> defaultdict(list)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> idx, num <span style=color:#f92672>in</span> enumerate(arr):
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>index[num]<span style=color:#f92672>.</span>append(idx)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>query</span>(self, left: int, right: int, value: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        low <span style=color:#f92672>=</span> bisect<span style=color:#f92672>.</span>bisect_left(self<span style=color:#f92672>.</span>index[value], left)
</span></span><span style=display:flex><span>        high <span style=color:#f92672>=</span> bisect<span style=color:#f92672>.</span>bisect_right(self<span style=color:#f92672>.</span>index[value], right)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> high <span style=color:#f92672>-</span> low
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(\log n)$ for each queries and $T(n) = O(n)$ for preprocessing</li><li>$S(n) = O(n)$ for holding the indexes</li></ul></div><div class=note id=99><div style=text-align:right;height:5px><a name=99 href=/notes_collection/lc_notes/99/ class="xxs grey monospace">99</a></div><h2 id=kmp-lcxxx>KMP [LC#xxx]</h2><blockquote><p>Question Description</p></blockquote><p>REF: <a href="https://www.youtube.com/watch?v=EL4ZbRF587g">https://www.youtube.com/watch?v=EL4ZbRF587g</a></p><h3 id=intuition>Intuition</h3><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>KMP</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, pattern):
</span></span><span style=display:flex><span>        <span style=color:#75715e># longest prefix suffix (LPS) array</span>
</span></span><span style=display:flex><span>        m <span style=color:#f92672>=</span> len(pattern)
</span></span><span style=display:flex><span>        lps <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span>m
</span></span><span style=display:flex><span>        length <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> m:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> pattern[length] <span style=color:#f92672>==</span> pattern[i]:
</span></span><span style=display:flex><span>                length <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                lps[i] <span style=color:#f92672>=</span> length
</span></span><span style=display:flex><span>                i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> length <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                    length <span style=color:#f92672>=</span> lps[length <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] 
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                    lps[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                    i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>lps <span style=color:#f92672>=</span> lps
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>pattern <span style=color:#f92672>=</span> pattern
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>match</span>(self, text):
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(text)
</span></span><span style=display:flex><span>        m <span style=color:#f92672>=</span> len(self<span style=color:#f92672>.</span>pattern)
</span></span><span style=display:flex><span>        matches <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> n:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>pattern[j] <span style=color:#f92672>==</span> text[i]:
</span></span><span style=display:flex><span>                i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                j <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> j <span style=color:#f92672>==</span> m:
</span></span><span style=display:flex><span>                matches<span style=color:#f92672>.</span>append(i <span style=color:#f92672>-</span> j)
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>lps[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>elif</span> i <span style=color:#f92672>&lt;</span> len(text) <span style=color:#f92672>and</span> self<span style=color:#f92672>.</span>pattern[j] <span style=color:#f92672>!=</span> text[i]:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> j <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                    j <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>lps[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                    i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> matches
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = $</li><li>$S(n) = $</li></ul></div><div class=note id=99a01><div style=text-align:right;height:5px><a name=99a01 href=/notes_collection/lc_notes/99a01/ class="xxs grey monospace">99a01</a></div><h2 id=rotate-image-lc48>Rotate Image [LC#48]</h2><blockquote><p>You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p></blockquote><h3 id=intuition>Intuition</h3><p>90 degree Rotation clockwise = tranpose + reflect</p><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rotate</span>(matrix: List[List[int]]) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(matrix)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># tranpose</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, n):
</span></span><span style=display:flex><span>            matrix[i][j], matrix[j][i] <span style=color:#f92672>=</span> matrix[j][i], matrix[i][j]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># reflect</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(n<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>            matrix[i][j], matrix[i][n<span style=color:#f92672>-</span>j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> matrix[i][n<span style=color:#f92672>-</span>j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], matrix[i][j]
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n)$</li><li>$S(n) = O(1)$</li></ul></div><div class=note id=99a02><div style=text-align:right;height:5px><a name=99a02 href=/notes_collection/lc_notes/99a02/ class="xxs grey monospace">99a02</a></div><p>Counting problems</p><h2 id=count-the-number-of-fair-pairs-lc2563>Count the Number of Fair Pairs [LC#2563]</h2><blockquote><p>Given an array two limits <code>[lower, upper]</code>, return the number of pairs in the array whose sum is withihg the limits (includive)</p></blockquote><h3 id=intuition>Intuition</h3><ul><li><code>Count[L &lt;= s &lt;= U] = Count[s &lt;= U] - Count[s &lt;= L - 1]</code></li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pairs_within_bounds</span>(self, nums: List[int], lower: int, upper: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    nums <span style=color:#f92672>=</span> sorted(nums)
</span></span><span style=display:flex><span>    U <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>count_lower_sorted(nums, upper)
</span></span><span style=display:flex><span>    L <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>count_lower_sorted(nums, lower <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> U <span style=color:#f92672>-</span> L
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pairs_below_bounds</span>(self, nums: List[int], th: int ):
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len(nums) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    counts <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>        s <span style=color:#f92672>=</span> nums[left] <span style=color:#f92672>+</span> nums[right]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> s <span style=color:#f92672>&lt;=</span> th:
</span></span><span style=display:flex><span>            counts <span style=color:#f92672>+=</span> right <span style=color:#f92672>-</span> left
</span></span><span style=display:flex><span>            left <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            right <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> counts
</span></span></code></pre></div><h3 id=time-complexity>Time complexity</h3><ul><li>$T(n) = O(n \log n) + O(n)$ dominated by sorting</li><li>$S(n) = O(1)$ if we sort in place.</li></ul></div></main><footer><p>Found something useful here? pass it on; or tell me about it!<nav><ul><li><a href="https://drive.google.com/drive/folders/18LU6PKnxy8rDrAXhpiPXV2yOYlO_I8cF?usp=sharing">Resume</a></li><li><a href=https://daxpy.xyz/omnia_mea>Coding notes</a></li><li><a href=https://www.linkedin.com/in/ndivakar/>Linkedin</a></li></ul></nav><small><a href=#top>↑ Top of page</a></small></p></footer></body></html>