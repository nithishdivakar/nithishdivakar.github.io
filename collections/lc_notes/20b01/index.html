<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><title>Russian Doll | DAXPY</title><link rel=stylesheet href=/css/main.min.94a2540136d9a839e3ae21136b6ed35c457b231d8bd1a157c7089710a8682c84.css integrity="sha256-lKJUATbZqDnjriETa27TXEV7Ix2L0aFXxwiXEKhoLIQ=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header><nav><ul><li><a class=text_secondary href=https://daxpy.xyz/>DAXPY</a></li><li>|</li><li><a href=https://daxpy.xyz/posts/>Posts</a></li><li><a href=https://daxpy.xyz/notes/>Notes</a></li><li><a href=https://daxpy.xyz/collections/>Collections</a></li><li><a href=https://daxpy.xyz/links/>Links</a></li><li><a href=https://daxpy.xyz/stories/>Stories</a></li><li><a href=/about>About</a></li></ul></nav></header><main><section><article><h2 id=russian-doll-envelopes-lc354>Russian Doll Envelopes [LC#354]</h2><blockquote><p>You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&rsquo;s width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).
<em>Note: You cannot rotate an envelope.</em></p></blockquote><h3 id=intuition>Intuition</h3><ul><li>The problem is a 2D version of Longest Increasing Subsequence, but since the item order is not static in the original problem, we can convert it to a 1D version as follows.</li><li>If a set of envelopes share same width, then 2 in such should not be selected. To ensure this, we sort the sequence in increasing order of width and then decreasing order of height. This also ensures that when a taller one is selected, the shorter ones are not selected after that.</li></ul><h3 id=code>Code</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>russian_dolls</span>(envelopes: List[List[int]]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    envelopes<span style=color:#f92672>.</span>sort(key<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> r: (r[<span style=color:#ae81ff>0</span>], <span style=color:#f92672>-</span>r[<span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>length_of_lis(h <span style=color:#66d9ef>for</span> w, h <span style=color:#f92672>in</span> envelopes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>length_of_lis</span>(nums: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> nums:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    tails <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> nums:
</span></span><span style=display:flex><span>        pos <span style=color:#f92672>=</span> bisect<span style=color:#f92672>.</span>bisect_left(tails, num)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> pos <span style=color:#f92672>==</span> len(tails):
</span></span><span style=display:flex><span>            tails<span style=color:#f92672>.</span>append(num)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            tails[pos] <span style=color:#f92672>=</span> num
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len(tails)
</span></span></code></pre></div><h3 id=run-time>Run time</h3><p>Time complexity for sorting is $O(n \log n)$ and for LIS it is $O(n \log n)$. Depending on the implementation, we need $O(n)$ extra space.</p><ul><li>$T(n) = O(n \log n)$ and $S(n) = O(n)$</li></ul></article></section></main><footer><p>Found something useful here? pass it on; or tell me about it!<nav><ul><li><a href="https://drive.google.com/drive/folders/18LU6PKnxy8rDrAXhpiPXV2yOYlO_I8cF?usp=sharing">Resume</a></li><li><a href=https://daxpy.xyz/collections/>Collections</a></li><li><a href=https://www.linkedin.com/in/ndivakar/>Linkedin</a></li></ul></nav><small><a href=#top>â†‘ Top of page</a></small></p></footer></body></html>