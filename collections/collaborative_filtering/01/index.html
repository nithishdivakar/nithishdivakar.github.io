<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><title>Collaborative Filtering Part 01 - The Foundations & Classic Flaws | DAXPY</title><link rel=stylesheet href=/css/main.min.d700ad2998f190f21436ef39c94129166ea316da7e0014005c9c2ced3b288a04.css integrity="sha256-1wCtKZjxkPIUNu85yUEpFm6jFtp+ABQAXJws7TsoigQ=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header><nav><ul><li><a class=text_secondary href=https://daxpy.xyz/>DAXPY</a></li><li>|</li><li><a href=https://daxpy.xyz/posts/>Posts</a></li><li><a href=https://daxpy.xyz/notes/>Notes</a></li><li><a href=https://daxpy.xyz/collections/>Collections</a></li><li><a href=https://daxpy.xyz/links/>Links</a></li><li><a href=https://daxpy.xyz/stories/>Stories</a></li><li><a href=/about>About</a></li></ul></nav></header><main><section><div style=text-align:right;height:5px;margin-top:10px class=italic>this page
⟩ <a href=/collections/collaborative_filtering/>collaborative filtering</a>
⟩ <a href=/collections/>collections</a>
⟩ <a href=/>home</a></div><article><h1 id=collaborative-filtering---the-foundations--classic-flaws>Collaborative Filtering - The Foundations & Classic Flaws</h1><p>When we step into recommendation-system land, our job is simple to state but hard to do:</p><blockquote><p>Figure out which content to recommend to a user.</p></blockquote><p>The easiest strategy is to show the most popular content and hope for the best. But can we do better?</p><p>Trying to do better means we want to figure out <strong>which content a particular user is likely to enjoy</strong>, not just what the crowd enjoys. That sounds straightforward until we hit two hard realities:</p><ul><li>R1: We have <em>lots</em> of users</li><li>R2: We have <em>lots</em> of content</li></ul><p>If we only had a handful of each, we could solve everything manually: just ask every user to sort every content by preference and call it a day. But nobody can rank a million movies (and we have millions of users too), so we need to predict instead of asking.</p><p>There’s one more complication: what does it even mean to &ldquo;like&rdquo; content? To stay grounded and practical, let&rsquo;s adopt a simple behavioral assumption:</p><blockquote><p>Users click content because they like it.</p></blockquote><p>Of course, real life is messier. People click for curiosity, boredom, mistakes, click-bait, doom-scrolling or butter fingers. But as a first step, let forge ahead with this assumption.</p><p>So the core problem becomes:</p><h2 id=pclick>P(click)</h2><p>Given a user and a content, can we predict the probability that the user will click it? or .. <strong>P(click | {content, user})</strong></p><p>A very quick Segue here. This P(click) problem underpins lot of other systems like ranking, feed, search and more. Simply what is meant by content and user might change to suit the problem.</p><h2 id=the-naive-approach-neighborhood-based-cf>The &ldquo;Naive&rdquo; Approach: Neighborhood-Based CF</h2><p>The initial solution to the P(click) problem is simple. Step 1: Find a set of simlar users. Step 2: Estimate P(click) as the fraction of those similar users who clicked the. Step 3: Done.</p><p>Simple &mldr; except we don’t actually know who the &ldquo;similar users&rdquo; are. So lets define it as the most obvious thing. <strong>Two users are similar if they clicked on same content</strong>.</p><p>This leads to the simplest possible collaborative filtering setup. We construct a user–item interaction matrix with each row for a user and each column for a content. Each cell = 1 if the user clicked the item, 0 otherwise.</p><p>Now to measure similarity between two users, we compare their rows. A straightforward method is to count how many items they both clicked (1s in common) versus how many items either of them clicked; compute Jaccard similarity of the user&rsquo;s clicks.</p><p>$$\text{Jaccard similarity} = \frac{\text{item both clicked}}{\text{ items either clicked}} $$</p><pre tabindex=0><code> 
      m1  m2  m3  m4  m5  m6 
    ┌───┬───┬───┬───┬───┬───┐ 
 u1 │   │ ✓ │   │ ✓ │   │ ✓ │ 
    ├───┼───┼───┼───┼───┼───┤ 
 u2 │ ✓ │ ✓ │   │   │   │   │ 
    ├───┼───┼───┼───┼───┼───┤ 
 u3 │ ✓ │ ✓ │   │ ✓ │   │   │ 
    └───┴───┴───┴───┴───┴───┘ 
     
         J(u1,u2) = 1/4
         J(u1,u3) = 2/4
         J(u2,u3) = 2/3
 
</code></pre><p>Jaccard similarity gives us a number between 0 and 1 for any pair of users, indicating their degree of similarity. With a reasonable threshold on this score, we can decide who counts as a “similar user.” Once we have that set, Step 2 and Step 3 follow immediately: compute P(click) as the fraction of those similar users who clicked on the item.</p><p>Finally, we recommend the items the user hasn’t clicked yet, sorted by this estimated P(click).
This approach is known as <strong>neighborhood-based collaborative filtering</strong>.</p><h2 id=neighborhood-based-collaborative-filtering>Neighborhood-Based Collaborative Filtering</h2><ul><li><p>[Step 1]: Construct the user–item interaction matrix</p><p>Each row represents a user, each column an item, and each cell is 1 if the user clicked the item, 0 otherwise.</p></li><li><p>[Step 2]: For each user, compute their Jaccard similarity with every other user using this matrix.</p><p>This gives a measure of how similar each pair of users is, based on their past clicks.</p></li><li><p>[Step 3]: For each user, identify their neighbor set as users whose similarity score is above a chosen threshold.
Then, estimate
$$P(click∣\{user,item\})= \frac{|\text{similar users who clicked the item}|}{|\text{similar users}|}$$</p></li><li><p>[Step 4:] Recommend the items the user hasn’t clicked yet, ranked by this estimated P(click).</p></li></ul><p>We used Jaccard similarity because it’s simple and intuitive. But there are many ways to measure similarity between two users.</p><p>In our setup, each user is represented as a vector with each dimension for an item, with 1 for clicked and 0 for not clicked.
That means we can use any distance or similarity metric that makes sense for binary vectors: cosine similarity, L1 norm, L2 norm, or others. Each metric has its own perks and problems.</p><p>But let us specifcally talk about problems with Jaccard Similarity. What are the flaws of Neighborhood-Based CF?</p><h2 id=flaws-of-neighborhood-based-cf>Flaws of Neighborhood-Based CF</h2><ol><li><p>Neighborhood-based CF only sees the surface level behavior.</p><p>Imagine you’re a user who likes horror, comedy, and drama. But suppose there’s no one else on the platform who likes all three genres at once. You&rsquo;ll probably have a few clicks with horror fans, a few with comedy fans, and a few with drama fans, but never enough with any single group to be considered similar. <strong>Your similarity score with everyone would be low even though your taste overlaps with many users in parts.</strong></p><p>In summary this approach can&rsquo;t capture composite behaviour. It completely misses deeper and latent behaviour.</p></li><li><p>Computationally expensive.</p><p>To find similar users, we need to compare every user with everyone else. So there are $O(N^2)$ comparisons; clearly impractical when when we have millions of users. Even if we use Approximate Nearest Neighbour (ANN) techniques to speed things up, we still face another problem. Each user is represented by a vector whose length equals the total number of items. And we have a lots of items.</p></li><li><p>Sparse interactions.</p><p>The user-item matrix is extremly sparse. Almost every cell is a zero. When we compare 2 users, there is very little overlap to base similarity on. Since Neighbourhood CF doesn&rsquo;t infer latent behaviour, it only recommend items with explict co-click evidence. This creates a negative feedback loop. Sparese Data -> No shared clicks -> no recommendation -> Sparse data.</p><p>Even for users whoe are genuinely simlar, we never make the connection because the model cannot infer the connection without explicit evidence.</p></li></ol><p><em>Note for practitioners. I have not brought up cold start problem because the next approach we discuss which solves most of the above issues, but not this one. We will bring it up later :)</em></p><h2 id=the-classic-foundation-matrix-factorization-mf>The Classic Foundation: Matrix Factorization (MF)</h2><h2 id=the-zero-problem-why-standard-mf-is-wrong-for-clicks>The &ldquo;Zero&rdquo; Problem: Why Standard MF is Wrong for Clicks</h2></article></section></main><footer><p>Found something useful here? pass it on; or tell me about it!<nav><ul><li><a href="https://drive.google.com/drive/folders/18LU6PKnxy8rDrAXhpiPXV2yOYlO_I8cF?usp=sharing">Resume</a></li><li><a href=https://daxpy.xyz/collections/>Collections</a></li><li><a href=https://www.linkedin.com/in/ndivakar/>Linkedin</a></li></ul></nav><small><a href=#top>↑ Top of page</a></small></p></footer></body></html>