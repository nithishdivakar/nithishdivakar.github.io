<!doctype html><html style=height:100%><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://daxpy.xyz/favicon.ico><link rel=stylesheet href=/css/style.min.css><link href="//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic" rel=stylesheet type=text/css><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><title>Finding Median</title></head><body style=height:100%><div class=container style=display:flex;flex-direction:column;min-height:100vh><div class=header><header id=banner style=display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:flex-start;align-items:baseline><big class=h2 style="flex: 0 0 80px;"><b><a href=https://daxpy.xyz/ class=black>daxpy</a></b></big><nav style=flex:0px><ul style=display:flex;flex-direction:row;gap:.5rem><li><a href=https://daxpy.xyz/notes/>Notes</a></li><li><a href=https://daxpy.xyz/posts/>Posts</a></li><li><a href=https://daxpy.xyz/links/>Links</a></li><li><a href=https://daxpy.xyz/random/>Random</a></li><li><a href=/about>about</a></li></ul></nav></header><hr style=margin:0></div><div class=main style=flex:1><main id=content><section><h1 id=finding-median>Finding Median</h1><p><em>Here is my <a href=https://www.dictionary.com/e/slang/eli5/>ELI5</a> definition of a median.</em></p><blockquote><p>&ldquo;Median is the middle number when numbers are sorted&rdquo;.</p></blockquote><p>There is only a single middle number when the size list is odd. But if the size is even, there are 2 middle numbers. Then we take an average of those 2 numbers to be the median.</p><p>Median is useful when your data doesn&rsquo;t behave. Medians are part of &ldquo;robust statistics&rdquo; because they are not affected by outliers. Both $[1,2,100]$ and $[1,2,3]$ have 2 as their median while their means differ widely. You can see why medians are not affected by noise.</p><p>This post is all about computing medians from a list of numbers. The straightforward approach is to sort everything first and the middle element is the median. But can we do better?</p><h2 id=quick-select>Quick Select</h2><p>Quick select is similar to quicksort except that it doesn&rsquo;t sort the array. It semi sorts the array.</p><p>Given an element &lsquo;pivot&rsquo;, quick select partitions the array such all the smaller elements are moved to the left of the pivot and all the larger elements are moved to the right; essentially partition the array into two. The partition procedure can be implemented using either <a href=https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme>Lomuto</a> or <a href=https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme>Hoare</a> scheme, either run in linear time.</p><p>Quick select takes a number $k$ as a parameter and finds the $k^{th}$ smallest number in the array. As a side effect, the first $k$ locations of the array contains the $k$ smallest elements after the procedure.</p><p>For finding the median, we can use quick selection by setting $k$ to the middle location.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>quick_select</span>(A, k):
</span></span><span style=display:flex><span>	low, high <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len(A)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>		pivot <span style=color:#f92672>=</span> random_index(low, high)
</span></span><span style=display:flex><span>		index <span style=color:#f92672>=</span> partition(A, low, high, A[pivot])
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> index <span style=color:#f92672>==</span> k:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> A[:k]
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> index <span style=color:#f92672>&lt;</span> k:
</span></span><span style=display:flex><span>			left <span style=color:#f92672>=</span> index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>			right <span style=color:#f92672>=</span> index <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>size <span style=color:#f92672>=</span> len(A) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>m1 <span style=color:#f92672>=</span> quick_select(A, size<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>m2 <span style=color:#f92672>=</span> quick_select(A, size <span style=color:#f92672>-</span> size<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>median <span style=color:#f92672>=</span> (m1<span style=color:#f92672>+</span>m2)<span style=color:#f92672>/</span><span style=color:#ae81ff>2.0</span>
</span></span></code></pre></div><p>The best-case and average-case complexity for quick select is both $O(n)$ but in the worst case, it takes $O(n^2)$ time. The worst case occurs when all the pivots we select results in an <em>unfavourable</em> partition of the array.</p><p>Is there any way to guarantee that the pivot we select results in a <em>favourable</em> split?</p><h2 id=median-of-medians>Median of Medians</h2><p>The algorithm is easier to describe. Split the large list into smaller lists. Find medians of the smaller lists(recursively) and then find the median of those medians. Use this number as the pivot in the partition function of quick select.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>median_small</span>(A):
</span></span><span style=display:flex><span>	size <span style=color:#f92672>=</span> len(A) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	B <span style=color:#f92672>=</span> sorted(A)
</span></span><span style=display:flex><span>	m1 <span style=color:#f92672>=</span> B[size<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>	m2 <span style=color:#f92672>=</span> B[size <span style=color:#f92672>-</span> size<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (m1<span style=color:#f92672>+</span>m2)<span style=color:#f92672>/</span><span style=color:#ae81ff>2.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>median_of_medians</span>(A, d <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>	n <span style=color:#f92672>=</span> len(A)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> d:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> median_small(A)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	medians <span style=color:#f92672>=</span> [median_small(A[i:i<span style=color:#f92672>+</span>d]) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, n, d)]    
</span></span><span style=display:flex><span>	pivot <span style=color:#f92672>=</span> median_of_medians(medians, d)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> pivot
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>quick_select</span>(A, k):
</span></span><span style=display:flex><span>	low, high <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len(A)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>		pivot <span style=color:#f92672>=</span> median_of_medians(A[low:high])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		index <span style=color:#f92672>=</span> partition(A, low, high, pivot)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> index <span style=color:#f92672>==</span> k:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> A[:k]
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> index <span style=color:#f92672>&lt;</span> k:
</span></span><span style=display:flex><span>			left <span style=color:#f92672>=</span> index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>			right <span style=color:#f92672>=</span> index <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>size <span style=color:#f92672>=</span> len(A) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>m1 <span style=color:#f92672>=</span> quick_select(A, size<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>m2 <span style=color:#f92672>=</span> quick_select(A, size <span style=color:#f92672>-</span> size<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>median <span style=color:#f92672>=</span> (m1<span style=color:#f92672>+</span>m2)<span style=color:#f92672>/</span><span style=color:#ae81ff>2.0</span>
</span></span></code></pre></div><p>Median of medians does not compute the real median. But it does give us something close. A guarantee that the selected pivot will always partition the array <em>favourably</em>.</p><p>A randomly selected element may end up partitioning the array <em>unfavourably</em> (i.e very little or no elements in one of the partitions). The recursion does not help reduce the running time in such a case. But what about the median of medians?</p><p>If $S_i$ is the $i^{th}$ segment of array $A$ with $|A|=n$, $|S_i|\geq 5$, $m_i=median(S_i)$, $m=median(m_1,m_2,\dots)$, we can infer that</p><ol><li>Atleast 2 element in $S_i$ are smaller than $m_i$</li><li>Atleast half of $m_i$&rsquo;s are smaller than $m$</li></ol><p>Which implies at least $\frac{n/5}{2}\cdot 2=\frac{n}{5}$ elements of $A$ are smaller than $m$. Similarly, at least $\frac{n}{5}$ elements in $A$ which are greater than $m$. So splitting the array with $m$ as pivot always results in a <em>favourable</em> split of the array.</p><p>The run time of median of median procedure is also linear.
$$T(n) = T(n/5)+ n/5 = O(n)$$</p><p>So if we use the median of medians for selecting pivot, the worst-case performance of quick select is improved to $O(n \log n)$.</p><p>But then why a magical segment size of $5$? Why not 3? Would a larger number work? Read more <a href=https://en.wikipedia.org/wiki/Median_of_medians>here</a></p><h2 id=median-of-sorted-arrays>Median of sorted arrays</h2><p>What if the numbers are in smaller sorted arrays and we need to find the median of the full list?</p><p>Here is the strategy. Given a pivot, we can count numbers smaller than the pivot in each of the sorted arrays using binary search. The smallest number for which this total count is $k$ is the $k^{th}$ smallest number in the whole collection. To find such a number, we can use binary search on the total range of numbers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_kth</span>(A:List[List[int]], k:int) <span style=color:#f92672>-&gt;</span> float:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(A)<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>: <span style=color:#66d9ef>return</span> A[<span style=color:#ae81ff>0</span>][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	lo <span style=color:#f92672>=</span> min(a[<span style=color:#ae81ff>0</span>]  <span style=color:#66d9ef>for</span> a <span style=color:#f92672>in</span> A)
</span></span><span style=display:flex><span>	hi <span style=color:#f92672>=</span> max(a[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>for</span> a <span style=color:#f92672>in</span> A)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> lo <span style=color:#f92672>&lt;</span> hi:
</span></span><span style=display:flex><span>		mid <span style=color:#f92672>=</span> lo <span style=color:#f92672>+</span> (hi <span style=color:#f92672>-</span> lo)<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> a <span style=color:#f92672>in</span> A:
</span></span><span style=display:flex><span>			count <span style=color:#f92672>+=</span> bisect<span style=color:#f92672>.</span>bisect_right(a, mid)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> count <span style=color:#f92672>&lt;</span> k:
</span></span><span style=display:flex><span>			lo <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>			hi <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> hi
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>median_sorted</span>(A:List[List[int]]) <span style=color:#f92672>-&gt;</span> float:
</span></span><span style=display:flex><span>	A <span style=color:#f92672>=</span> [a <span style=color:#66d9ef>for</span> a <span style=color:#f92672>in</span> A <span style=color:#66d9ef>if</span> a] <span style=color:#75715e># remove all empty arrays</span>
</span></span><span style=display:flex><span>	size <span style=color:#f92672>=</span> sum(len(a) <span style=color:#66d9ef>for</span> a <span style=color:#f92672>in</span> A) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	m1 <span style=color:#f92672>=</span> find_kth(A, size<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	m2 <span style=color:#f92672>=</span> find_kth(A, size <span style=color:#f92672>-</span> size<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (m1<span style=color:#f92672>+</span>m2)<span style=color:#f92672>/</span><span style=color:#ae81ff>2.0</span>
</span></span></code></pre></div><p>The time complexity of this approach is $O(m\log n)$ where $m$ is no of arrays and $n$ is the size of the largest array.</p><p><em>To be precise, the time complexity is $O(b\cdot m \log n)$ where $b$ is the total number of bits used to represent the numbers. The difference between <code>hi</code> and <code>lo</code> can be as large as $2^{b}$ and we are doing a binary search in that range. So, the number of steps the while loop runs is bounded by $O(b)$. In a realistic scenario, $b$ is always a constant like 32 or 64.</em></p><h2 id=median-with-updates>Median with updates</h2><p>So far we have been talking about arrays of fixed sizes. What if the array grows over time with insertions? How do you find the median instantaneously?</p><p>Essentially, we have to support 2 operations. <code>insert</code> and <code>find_median</code>. If insertion is a simple append operation, then finding the median would take $O(n)$ steps. If we always insert while maintaining sorted order which takes $O(n)$ steps, then finding the median would just be a lookup. Can we do better?</p><p>We maintain 2 heaps; a max heap and a min-heap. The max heap always maintains the smaller half of elements while the min-heap maintains the larger half. The roots of both the heaps would be the middle element(s).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> heapq
</span></span><span style=display:flex><span>L, R <span style=color:#f92672>=</span> [], []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>insert</span>(num) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>	heapq<span style=color:#f92672>.</span>heappush(R, num)
</span></span><span style=display:flex><span>	itm <span style=color:#f92672>=</span> heapq<span style=color:#f92672>.</span>heappop(R)
</span></span><span style=display:flex><span>	heapq<span style=color:#f92672>.</span>heappush(L, <span style=color:#f92672>-</span>itm)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(R) <span style=color:#f92672>&lt;</span> len(L): 
</span></span><span style=display:flex><span>		<span style=color:#75715e># invariant: |R|-|L| = 0/1 </span>
</span></span><span style=display:flex><span>		itm <span style=color:#f92672>=</span> heapq<span style=color:#f92672>.</span>heappop(L)
</span></span><span style=display:flex><span>		heapq<span style=color:#f92672>.</span>heappush(R, <span style=color:#f92672>-</span>itm)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_median</span>() <span style=color:#f92672>-&gt;</span> float:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(L) <span style=color:#f92672>==</span> len(R):
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> (<span style=color:#f92672>-</span>L[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> R[<span style=color:#ae81ff>0</span>])<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> R[<span style=color:#ae81ff>0</span>]
</span></span></code></pre></div><p>This scheme incurs a $O(\log n)$ steps for <code>insert</code> and $O(1)$ for <code>find_median</code>.
<em>We do a bit of hack by inserting the negative of an element to simulate a max heap from a min-heap</em>.</p><h2 id=median-of-a-distribution>Median of a distribution</h2><p>Let&rsquo;s say we have lots of numbers. But most of them are in a small range. How do you compute the median then?</p><p>We can store the statistics of the numbers by maintaining their frequencies in the valid range. For the numbers beyond the range, we store only the total counts (one for each end). This allows fast inserts and fast median finding operations. Let&rsquo;s see a sample implementation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>freq <span style=color:#f92672>=</span> Counter()
</span></span><span style=display:flex><span>low, high <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>?</span>, <span style=color:#960050;background-color:#1e0010>?</span> <span style=color:#75715e># set the limits here</span>
</span></span><span style=display:flex><span>low_counter, count, high_counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>insert</span>(num) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> num <span style=color:#f92672>&lt;</span> low:
</span></span><span style=display:flex><span>		low_counter <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>elif</span> num <span style=color:#f92672>&gt;</span> high:
</span></span><span style=display:flex><span>		high_counter <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>		freq[num] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_kth</span>(k) <span style=color:#f92672>-&gt;</span> float:
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> low_counter
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> range(low, high<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> count <span style=color:#f92672>&lt;=</span> k <span style=color:#f92672>&lt;=</span> (count <span style=color:#f92672>+</span> freq[n]):
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> n
</span></span><span style=display:flex><span>		count <span style=color:#f92672>+=</span> freq[n]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> float(<span style=color:#e6db74>&#39;nan&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_median</span>() <span style=color:#f92672>-&gt;</span> float:
</span></span><span style=display:flex><span>	size <span style=color:#f92672>=</span> low_counter <span style=color:#f92672>+</span> count <span style=color:#f92672>+</span> high_counter <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	m1 <span style=color:#f92672>=</span> find_kth(size<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	m2 <span style=color:#f92672>=</span> find_kth(size <span style=color:#f92672>-</span> size<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (m1 <span style=color:#f92672>+</span> m2)<span style=color:#f92672>/</span><span style=color:#ae81ff>2.0</span>
</span></span></code></pre></div><p>Do you know any other weird scenarios where you need median computed? Let me know.</p><br><br><br><i>tags:</i>
<a class=gray style=padding-right:5px href=/tags#algorithms>algorithms</a></section></main></div><div class=footer><br><br><hr style=margin:0><footer id=footer><div>Ping me <a class=green href=https://twitter.com/nithishdivakar>@nithishdivakar</a></div><div><a href=/resources>::</a></div></footer></div></div></body></html>