<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><title>XGBoost | DAXPY</title><link rel=stylesheet href=/css/main.min.9e0d91ee5e43768adbd3e495fb3273f760195e4e09cae07eb8461013ded5303d.css integrity="sha256-ng2R7l5Ddorb0+SV+zJz92AZXk4JyuB+uEYQE97VMD0=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header><nav><ul><li><a class=text_secondary href=https://daxpy.xyz/>DAXPY</a></li><li>|</li><li><a class=text_secondary href=https://daxpy.xyz/posts/>posts</a></li><li><a class=text_secondary href=https://daxpy.xyz/notes/>notes</a></li><li><a class=text_secondary href=https://daxpy.xyz/links/>links</a></li><li><a class=text_secondary href=https://daxpy.xyz/stories/>stories</a></li><li><a class=text_secondary href=/about>about</a></li></ul></nav></header><main><section><article><h1 id=xgboost>XGBoost</h1><p><strong>Extreme Gradient Boosting</strong> or XGBoost is a technique that has become quite useful for solving prediction problems. XGBoost is also quite interesting academically; for it combines quite few techniques together to give us one robust method. The technique is composed from gradient boosting, decision trees, matching pursuit and gradient descent in function space among others. In this post, we will explore and derive the inner workings of XGBoost.</p><h2 id=the-regression-problem>The Regression Problem</h2><p>We are given a set of samples from population $\{(y_i,x_i)\}_{i=1}^{N}$ which we call a dataset. $y$&rsquo;s are scalars and $x$ are vectors.</p><p>There is also some function $F^{\ast}$ on the population which perfectly determines the entire population i.e. $y = F^{\ast}(x)$. However, this function is unknown and all we have is the dataset.</p><p>Regression problem is computing some $\hat{F}$ which is the best approximation of $F^{\ast}$ that minimises some loss function $L(y,F(x))$ over all values of $(y,x)$.</p><p>Different choices of $L$ and restriction on the structrue of $F$ leads to different algorithms. For example; mean squared error and linear function on $x$ gives <a href=https://en.wikipedia.org/wiki/Linear_regression title="Linear Regression">linear regession</a>.</p><h2 id=the-family-of-functions>T.H.E family of functions</h2><p>Let assume (to make things easier) that $F$ has a simpler structure. The all powerful $F$ is from the family of functions which are weighted combination of simpler functions.</p><p>$$F(x) = \sum \beta_m h_m(x)$$</p><p>We do such approximations all the time. See <a href=https://www.cs.cmu.edu/~epxing/Class/10708-17/notes-17/10708-scribe-lecture13.pdf>mean field approximation for variational inference</a> for a family which is <em>product</em> of simpler functions.</p><p>This makes our <em>learning</em> easier. It&rsquo;s easier to see if we look at the explict structure of $F$.</p><p>$$F(x;\{\beta_t,\alpha_t\}) = \sum_t \beta_t h_t(x;\alpha_t)$$</p><p>All we need to do now is compute values of parameters $\beta$&rsquo;s and $\alpha$&rsquo;s which minimised $L$.</p><p>By the way, did we just sneak in a constraint on structure of $F$ ??? Are all the $h$&rsquo;s same or different?</p><p>Well the structure allows everything. B.U.T, for XGBoost, all $h$&rsquo;s are <a href=https://en.wikipedia.org/wiki/Decision_tree_learning title="Decision Tree">decision trees</a>.</p><h2 id=gradient-boosting>Gradient Boosting</h2><blockquote><p>All we need to do is compute $\beta$&rsquo;s and $\alpha$&rsquo;s</p></blockquote><p>This is easier said than done.</p><p>Joint optimisation will lead to a situation where adjusting $\alpha$ of one tree would require us to adjust $\alpha$ of another. And $\alpha$ of a decision tree determines where to add a split. This is not productive at all as we will have to throw away the existing tree and construct a whole new tree. In optimisation land this is classif case of a dis-continous objective.</p><p>So lets fix that problem by fixing things. We first find the best parameters for $h_1$ and then never change it. Then find best parameters for $h_2$ and so on. This idea is called &ldquo;Gradient Boosting&rdquo; where we restrict $F$ to the family of <em>additive expansion</em> is from the paper <a href=https://projecteuclid.org/journals/annals-of-statistics/volume-29/issue-5/Greedy-function-approximation-A-gradient-boosting-machine/10.1214/aos/1013203451.pdf title='Friedman, Jerome H. "Greedy function approximation: a gradient boosting machine" In Annals of statistics , (2001)'>Greedy Function Approximation: A Gradient Boosting Machine</a>. This stage wise stratergy is also very similar to <a href=http://www.iro.umontreal.ca/~pift6080/H09/documents/papers/sparse/mallat_zhang_matching_pursuit.pdf title='Mallat, Stephane G and Zhang, Zhifeng "Matching pursuits with time-frequency dictionaries" In IEEE Transactions on signal processing 41, (1993)'>matching pursuit algorithm</a> in signal processing.</p><blockquote><p>Given an loss function $l$ and parameterised objective function $f(x;\theta)$, we can find best $\theta$ which minimises $l$ using <a href=https://en.wikipedia.org/wiki/Gradient_descent title="Gradient Descent">Gradient Descent</a>. $$\theta \gets \theta - \gamma \nabla_l f$$</p></blockquote><p>Let say we are following the approach of fixing things as listed above. We are in some intermediate step $m$. We have already found and fixed the parameters of $\beta_{1:m-1}$ and $\alpha_{1:m-1}$ and the current best regressor we have is</p><p>$$F_{t-1}(x) = \sum_{i=1}^{t-1} \beta_i h_i(x; \alpha_i)$$</p><p>We want to add to this a $p_t(x) = \beta_t h_t(x;\alpha_t)$ and reduce the error further.</p><p>$$ l_t = \operatorname{arg min} \sum_{i=1}^{N} \operatorname{L}(y_i, F_{t-1}(x)+f_t(x))$$</p><p>In this situation we can find best parameters for $f_t$ using gradient descent on function space. But we need $\frac{\partial l_t}{\partial f_t}$.
Let ignore a few things a write this situation simply as</p><p>$$l = \operatorname{L}(y, p+f(x))$$</p><p>If we squint our eyes, r.h.s looks like a function with a fixed point $p$ and a small delta $f(x)$. We can expand it around the fix point using second order <a href=https://en.wikipedia.org/wiki/Taylor_series title="Taylor's Series">taylor&rsquo;s series</a> approximation.</p><p>$$l = \operatorname{L}(y, p) + \nabla_p \operatorname{L}(y,p) f(x) + \nabla_p^2 \operatorname{L}(y,p) \frac{f(x)^2}{2} $$</p><p>This immediatly gives us an opening to get the derivative of loss w.r.to $f(x)$.</p><p>$$\frac{\partial l}{\partial f} =0 + \nabla_p \operatorname{L}(y,p) + \nabla_p^2 \operatorname{L}(y,p) f(x) = \nabla_p^2 \left( \frac{\nabla_p}{\nabla_p^2} + f(x)\right)$$</p><p>Since optimum occurs at the saddle point, the optimum $f(x)$ is the one which makes the derivative zero. So at $\frac{\partial l}{\partial f} =0$ we have
$$f(x) = - \frac{\nabla_p}{\nabla_p^2}$$</p><p>Ultimately, to find the best additive function to the model at stage $t$, we simply have to fit $h_t(x)$ to predict the residuals $\{-{\nabla_p}/{\nabla_p^2} \}$. This again is another regression problem.</p><p>$$h_t \leftrightsquigarrow \left\{\left(x_i,-{\nabla_{F_{t-1}(x_i)}}\middle/{\nabla^2_{F_{t-1}(x_i)} }\right)\right\}_{i=1}^{n}$$</p><p><strong>Addendum</strong>: What if we use first order taylor&rsquo;s series approximation instead on the loss function? What will be the residuals in the last step?</p><h2 id=xgboost-algorithm>XGBoost Algorithm</h2><ul><li>We begin by setting $h_0$ to simply predict $\mathbb{E}(y)$.</li><li>At each step we first compute the residuals
$$ r_i = -\frac{\nabla_{\bar{y}_i}\operatorname{L}(y_i, \bar{y}_i)}{\nabla^2_{\bar{y}_i}\operatorname{L}(y_i, \bar{y}_i)} ; with~\bar{y}_i = F_{t-1}(x_i)$$
<em>Note:</em> Most loss functions have easy analytical form of first and second derivatives e.g. mse loss.</li><li>Fit $h_t$ to predict $r_i$ given $x_i$.</li><li>Compute $\beta_t$ using line search which will optimise
$$\operatorname{arg min}_{\beta_t}\operatorname{L}(y, F_{t-1} + \beta_t h_t)$$</li><li>Update the model as
$$F_t = F_{t-1} + \beta_t h_t$$</li></ul><h2 id=addendum>Addendum</h2><p>There is a lot more to implementing XGBoost. Most of it is centered around the &ldquo;fitting a new tree to residuals&rdquo; part. A few scenarios that arise in this step are</p><ul><li>How to prevent overfitting of the intermediate tree on residuals?</li><li>How to let user direct/control some part of the tree construction so that the complexity vs performance tradeoff can be tunable?</li></ul><p><a href=https://arxiv.org/pdf/1603.02754.pdf title='Chen, Tianqi and Guestrin, Carlos "Xgboost: A scalable tree boosting system" In Proceedings of the 22nd acm sigkdd international conference on knowledge discovery and data mining pp.785--794, (2016)'>Chen et al. (2016)</a> gives an excellet account of these issues among other, but the official <a href=https://xgboost.readthedocs.io/en/latest/tutorials/model.html>XGBoost library&rsquo; documentation</a> is also a great source for discussion on these topics.</p><h2 id=references>References</h2><reference><small><ul><li><p><a href=https://projecteuclid.org/journals/annals-of-statistics/volume-29/issue-5/Greedy-function-approximation-A-gradient-boosting-machine/10.1214/aos/1013203451.pdf title='Friedman, Jerome H. "Greedy function approximation: a gradient boosting machine" In Annals of statistics , (2001)'>Friedman (2001)</a>: Friedman, Jerome H. &ldquo;<em>Greedy function approximation: a gradient boosting machine</em>&rdquo; In Annals of statistics , (2001)</p></li><li><p><a href=http://www.iro.umontreal.ca/~pift6080/H09/documents/papers/sparse/mallat_zhang_matching_pursuit.pdf title='Mallat, Stephane G and Zhang, Zhifeng "Matching pursuits with time-frequency dictionaries" In IEEE Transactions on signal processing 41, (1993)'>Mallat and Zhang (1993)</a>: Mallat, Stephane G and Zhang, Zhifeng &ldquo;<em>Matching pursuits with time-frequency dictionaries</em>&rdquo; In IEEE Transactions on signal processing 41, (1993)</p></li><li><p><a href=https://arxiv.org/pdf/1603.02754.pdf title='Chen, Tianqi and Guestrin, Carlos "Xgboost: A scalable tree boosting system" In Proceedings of the 22nd acm sigkdd international conference on knowledge discovery and data mining pp.785--794, (2016)'>Chen et al. (2016)</a>: Chen, Tianqi and Guestrin, Carlos &ldquo;<em>Xgboost: A scalable tree boosting system</em>&rdquo; In Proceedings of the 22nd acm sigkdd international conference on knowledge discovery and data mining pp. 785&ndash;794, (2016)</p></li><li><p><em><a href=https://en.wikipedia.org/wiki/Decision_tree_learning title="Decision Tree">Decision Tree</a></em><br><small><em><code>https://en.wikipedia.org/wiki/Decision_tree_learning</code></em></small></p></li><li><p><em><a href=https://en.wikipedia.org/wiki/Gradient_descent title="Gradient Descent">Gradient Descent</a></em><br><small><em><code>https://en.wikipedia.org/wiki/Gradient_descent</code></em></small></p></li><li><p><em><a href=https://en.wikipedia.org/wiki/Linear_regression title="Linear Regression">Linear Regression</a></em><br><small><em><code>https://en.wikipedia.org/wiki/Linear_regression</code></em></small></p></li><li><p><em><a href=https://en.wikipedia.org/wiki/Taylor_series title="Taylor's Series">Taylor series</a></em><br><small><em><code>https://en.wikipedia.org/wiki/Taylor_series</code></em></small></p></li></ul></small></reference></article><br><br><br><i>tags:</i>
<a class=gray style=padding-right:5px href=/tags#machine-learning><i>#machine-learning</i></a></section></main><footer><p>...</p></footer></body></html>