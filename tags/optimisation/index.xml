<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>optimisation on daxpy</title><link>https://daxpy.xyz/tags/optimisation/</link><description>Recent content in optimisation on daxpy</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 04 Jan 2022 05:04:51 +0530</lastBuildDate><atom:link href="https://daxpy.xyz/tags/optimisation/index.xml" rel="self" type="application/rss+xml"/><item><title>Binary Search</title><link>https://daxpy.xyz/posts/binary-search-problems/</link><pubDate>Fri, 28 Jan 2022 06:59:51 +0530</pubDate><guid>https://daxpy.xyz/posts/binary-search-problems/</guid><description>&lt;h1 id="binary-search">Binary Search&lt;/h1>
&lt;p>Binary search is more than just a search algorithm for sorted arrays. It&amp;rsquo;s an algorithm which keeps showing up as optimal solutions in unlikely places. This note is a very limited exploration of what binary search can do.&lt;/p>
&lt;p>Let&amp;rsquo;s begin by talking about vanilla binary search.&lt;/p>
&lt;h2 id="binary-search-1">Binary Search&lt;/h2>
&lt;p>We are given a sorted array of numbers and a target. Binary search is the most optimal way of finding position of target in the array if present.&lt;/p>
&lt;p>Binary search starts by having the entire array as a search space. It then progressively compares the middle element with the target, eliminating half pf search space as not needing further exploration w.r.to the relativeness of target and middle element.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">binary_search&lt;/span>(nums, target):
low, high &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, len(nums)
&lt;span style="color:#66d9ef">while&lt;/span> low &lt;span style="color:#f92672">&amp;lt;&lt;/span> high:
mid &lt;span style="color:#f92672">=&lt;/span> low &lt;span style="color:#f92672">+&lt;/span> (high&lt;span style="color:#f92672">-&lt;/span>low)&lt;span style="color:#f92672">//&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> nums[mid] &lt;span style="color:#f92672">==&lt;/span> target:
&lt;span style="color:#66d9ef">return&lt;/span> mid
&lt;span style="color:#66d9ef">if&lt;/span> nums[mid] &lt;span style="color:#f92672">&amp;lt;&lt;/span> target:
low &lt;span style="color:#f92672">=&lt;/span> mid&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">else&lt;/span>:
high &lt;span style="color:#f92672">=&lt;/span> mid
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The basic structure of binary search can be used to solve many other seemingly different problems. A one line abstraction of such problems is&lt;/p>
&lt;blockquote>
&lt;p>Find a lowest value in a range which is feasible&lt;/p>
&lt;/blockquote>
&lt;p>Lets describe the search in sorted array problem in this framework.&lt;/p>
&lt;p>Instead of trying to find the location of target, let us recast the problem as the smallest index in the which contains elements which are larger than or equal to target. Note that this is no longer solving the search problem exactly. The difference in when target is not present in the array.&lt;/p>
&lt;p>In this description, an index in the array is feasible if the element at the index is larger than or equal to target&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">feasible&lt;/span>(index, nums, target):
&lt;span style="color:#66d9ef">return&lt;/span> (nums[index]&lt;span style="color:#f92672">&amp;gt;=&lt;/span>target)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">binary_search&lt;/span>(nums, target):
low, high &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, len(nums)
&lt;span style="color:#66d9ef">while&lt;/span> low &lt;span style="color:#f92672">&amp;lt;&lt;/span> high:
mid &lt;span style="color:#f92672">=&lt;/span> low &lt;span style="color:#f92672">+&lt;/span> (high&lt;span style="color:#f92672">-&lt;/span>low)&lt;span style="color:#f92672">//&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> feasible(mid, nums, target):
high &lt;span style="color:#f92672">=&lt;/span> mid
&lt;span style="color:#66d9ef">else&lt;/span>
low &lt;span style="color:#f92672">=&lt;/span> mid&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> low
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This template can be quickly extended to solve a few other problems.&lt;/p>
&lt;h2 id="split-array-largest-sum">Split array largest sum&lt;/h2>
&lt;p>Given an array which consists of non-negative integers, split array into M non-empty contiguous sub-arrays such that the largest sum of the segments is minimum.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">feasible&lt;/span>(threshold, M) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> bool:
count, total &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> num &lt;span style="color:#f92672">in&lt;/span> nums:
total &lt;span style="color:#f92672">+=&lt;/span> num
&lt;span style="color:#66d9ef">if&lt;/span> total &lt;span style="color:#f92672">&amp;gt;&lt;/span> threshold:
total &lt;span style="color:#f92672">=&lt;/span> num
count &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> count &lt;span style="color:#f92672">&amp;gt;&lt;/span> M:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">binary_search&lt;/span>(nums) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> int:
low, high &lt;span style="color:#f92672">=&lt;/span> max(nums), sum(nums)
&lt;span style="color:#66d9ef">while&lt;/span> low &lt;span style="color:#f92672">&amp;lt;&lt;/span> high:
mid &lt;span style="color:#f92672">=&lt;/span> low &lt;span style="color:#f92672">+&lt;/span> (high &lt;span style="color:#f92672">-&lt;/span> low)&lt;span style="color:#f92672">//&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> feasible(mid, M):
high &lt;span style="color:#f92672">=&lt;/span> mid
&lt;span style="color:#66d9ef">else&lt;/span>:
low &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> low
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now lets look at another problem with similar structure.&lt;/p>
&lt;h2 id="median-in-a-row-wise-sorted-matrix">Median in a row wise sorted Matrix&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">binary_median&lt;/span>(A):
m, n &lt;span style="color:#f92672">=&lt;/span> len(A),len(A[&lt;span style="color:#ae81ff">0&lt;/span>])
low &lt;span style="color:#f92672">=&lt;/span> min(A[i][ &lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(m))
high &lt;span style="color:#f92672">=&lt;/span> max(A[i][&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(m))
median_loc &lt;span style="color:#f92672">=&lt;/span> (m &lt;span style="color:#f92672">*&lt;/span> n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> low &lt;span style="color:#f92672">&amp;lt;&lt;/span> high:
mid &lt;span style="color:#f92672">=&lt;/span> low &lt;span style="color:#f92672">+&lt;/span> (high &lt;span style="color:#f92672">-&lt;/span> low) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
count &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(m):
count &lt;span style="color:#f92672">+=&lt;/span> upper_bound(A[i], mid)
&lt;span style="color:#66d9ef">if&lt;/span> count &lt;span style="color:#f92672">&amp;lt;&lt;/span> median_loc:
low &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">else&lt;/span>:
high &lt;span style="color:#f92672">=&lt;/span> mid
&lt;span style="color:#66d9ef">return&lt;/span> high &lt;span style="color:#75715e"># is median&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="square-root-of-a-number">Square root of a number&lt;/h2>
&lt;p>Binary search can also used to find roots of an equations. Let us demonstrate how it is used to find square root of a number.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">square_root&lt;/span>(x, tolerance&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1e-4&lt;/span>):
low, high &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,x
&lt;span style="color:#66d9ef">while&lt;/span> (high&lt;span style="color:#f92672">-&lt;/span>low) &lt;span style="color:#f92672">&amp;gt;&lt;/span> tolerance:
mid &lt;span style="color:#f92672">=&lt;/span> low &lt;span style="color:#f92672">+&lt;/span> (high &lt;span style="color:#f92672">-&lt;/span> low)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2.0&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> mid &lt;span style="color:#f92672">*&lt;/span> mid &lt;span style="color:#f92672">&amp;lt;=&lt;/span> x:
low &lt;span style="color:#f92672">=&lt;/span> mid
&lt;span style="color:#66d9ef">else&lt;/span>:
high &lt;span style="color:#f92672">=&lt;/span> mid
&lt;span style="color:#66d9ef">return&lt;/span> low
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="find-minimum-in-rotated-sorted-array-with-no-duplicates">Find Minimum in Rotated Sorted Array With No Duplicates&lt;/h2>
&lt;p>\url{https://www.topcoder.com/thrive/articles/Binary%20Search}&lt;/p>
&lt;h2 id="median-of-2-sorted-arrays">Median of 2 sorted arrays&lt;/h2></description></item><item><title>Knapsack</title><link>https://daxpy.xyz/posts/knapsack/</link><pubDate>Fri, 28 Jan 2022 06:59:51 +0530</pubDate><guid>https://daxpy.xyz/posts/knapsack/</guid><description>&lt;h1 id="knapsack">Knapsack&lt;/h1>
&lt;p>The following is the description of knapsack problem.&lt;/p>
&lt;p>We are given a set of items each with its own weight ($w_i$) and value ($v_i$). We are also given a limit or maximum capacity $T$.
How do we select a subset of items such that the total weight is within the limit, but the total value is maximum?&lt;/p>
&lt;p>$$\begin{align}
&amp;amp;\max; \sum x_i v_i
\
&amp;amp;s.t. \quad \sum x_i w_i \leq T
\end{align}$$&lt;/p>
&lt;p>Recurrence relation solving the problem
$$S_{k,t} = \max {S_{k-1,t}, v_k + S_{k-1,t-w_k}}$$&lt;/p>
&lt;p>$S_{k,t}$ represents maximum value that can be achieved which has a maximum weight of $t$ with some subset of first $k$ items.&lt;/p>
&lt;p>Can we select more that one of the same item?&lt;/p>
&lt;p>Restricted cases of knapsack are more interesting. Minimising counts of items (value of each item is 1) while constraining on overall sum amounts to a selection problem. And the question we are solving for essentially is what is the minimum number of items we can select which gives us the aspired value.&lt;/p>
&lt;h2 id="bounded-knapsacks">Bounded knapsacks&lt;/h2>
&lt;p>Bounded knapsacks is when we have at most $c$ copies of each item. We need to only consider the case when we have only a single copy of each item or &lt;strong>0/1 knapsack&lt;/strong>. We can extending 0/1 knapsack to bounded knapsack by creating copies of items which occur more than one.&lt;/p>
&lt;h3 id="01-knapsack">0/1 knapsack&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># O(nT) time, O(T) space&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">knapsack_01&lt;/span>(nums,T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> int:
nums&lt;span style="color:#f92672">.&lt;/span>sort()
dp &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> _ &lt;span style="color:#f92672">in&lt;/span> range(T&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)]
&lt;span style="color:#66d9ef">for&lt;/span> num &lt;span style="color:#f92672">in&lt;/span> nums:
&lt;span style="color:#66d9ef">if&lt;/span> num &lt;span style="color:#f92672">&amp;gt;&lt;/span> T: &lt;span style="color:#66d9ef">break&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> slack &lt;span style="color:#f92672">in&lt;/span> range(T&lt;span style="color:#f92672">-&lt;/span>num,&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>):
&lt;span style="color:#66d9ef">if&lt;/span> dp[slack] &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
dp[slack &lt;span style="color:#f92672">+&lt;/span> num] &lt;span style="color:#f92672">=&lt;/span> max(
dp[slack &lt;span style="color:#f92672">+&lt;/span> num],
dp[slack]&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
dp[num] &lt;span style="color:#f92672">=&lt;/span> max(dp[num], &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> dp[T]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A few things to unpack here on what the algorithm is doing.&lt;/p>
&lt;p>First we are sorting all the&lt;/p>
&lt;p>Time complexity is $O(n\log n)$ for sorting the items and $O(nT)$
for computing the optimal answer. The algorithm also uses a $O(T)$ sized array for storing solutions of sub-problems.&lt;/p>
&lt;h2 id="unbounded-knapsack">Unbounded knapsack&lt;/h2>
&lt;p>When we have infinite copies of each items, we have &lt;strong>unbounded knapsack&lt;/strong> problem. $x_i &amp;gt; 0$ and $x_i\in \mathbb{Z}$&lt;/p>
&lt;p>A classic example of unbounded knapsack is coin change problem.&lt;/p>
&lt;h3 id="coin-change">Coin Change&lt;/h3>
&lt;p>Given a set of coins denomination find the smallest collection of coins that add up to a given amount.&lt;/p>
&lt;p>The problem is an instance of unbounded &lt;a href="app://obsidian.md/Knapsack">knapsack&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">coin_change&lt;/span>(coins, amount):
dp &lt;span style="color:#f92672">=&lt;/span> [float(&lt;span style="color:#e6db74">&amp;#39;inf&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">for&lt;/span> _ &lt;span style="color:#f92672">in&lt;/span> range(amount&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)]
dp[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> coin &lt;span style="color:#f92672">in&lt;/span> coins:
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(coin, amount&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>):
dp[i] &lt;span style="color:#f92672">=&lt;/span> min(dp[i], dp[i&lt;span style="color:#f92672">-&lt;/span>coin]&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> dp[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#66d9ef">if&lt;/span> dp[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">!=&lt;/span> float(&lt;span style="color:#e6db74">&amp;#39;inf&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="fractional-knapsack">Fractional Knapsack&lt;/h2>
&lt;p>$x_i \in [0,1]$ $$\begin{align}
&amp;amp;\max \sum x_iv_i
\
&amp;amp; s.t. \quad \sum x_iw_i \leq T\end{align}$$
Can be solved using greedy algorithm in $O(n \log n)$.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">v,w &lt;span style="color:#f92672">=&lt;/span> unzip(sorted(zip(v,w),key&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">lambda&lt;/span> r:r[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">/&lt;/span>r[&lt;span style="color:#ae81ff">1&lt;/span>]))
x &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">0.0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(n)]
C &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.0&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> i range(n):
x[i] &lt;span style="color:#f92672">=&lt;/span> min((T&lt;span style="color:#f92672">-&lt;/span>C)&lt;span style="color:#f92672">/&lt;/span>w[i],&lt;span style="color:#ae81ff">1.0&lt;/span>)
C &lt;span style="color:#f92672">+=&lt;/span> w[i] &lt;span style="color:#f92672">*&lt;/span> x[i]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>References&lt;/p>
&lt;ul>
&lt;li>[[Coin Change]]&lt;/li>
&lt;li>[[Knapsack_01]]&lt;/li>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title>With and max structure in Algorithms</title><link>https://daxpy.xyz/posts/2021-04-30-with-and-max-structure-of-algorithms/</link><pubDate>Fri, 30 Apr 2021 05:04:51 +0530</pubDate><guid>https://daxpy.xyz/posts/2021-04-30-with-and-max-structure-of-algorithms/</guid><description>&lt;h1 id="kadanes-algorithm">Kadane&amp;rsquo;s Algorithm&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">maxSubArraySum&lt;/span>(a,size):
&lt;span style="color:#75715e">##Your code here&lt;/span>
max_sum,max_start,max_end &lt;span style="color:#f92672">=&lt;/span> a[&lt;span style="color:#ae81ff">0&lt;/span>],&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0&lt;/span>
max_sum_with,max_with_start,max_with_end &lt;span style="color:#f92672">=&lt;/span> a[&lt;span style="color:#ae81ff">0&lt;/span>],&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> i,ele &lt;span style="color:#f92672">in&lt;/span> enumerate(a[&lt;span style="color:#ae81ff">1&lt;/span>:],&lt;span style="color:#ae81ff">1&lt;/span>):
&lt;span style="color:#66d9ef">if&lt;/span> max_sum_with&lt;span style="color:#f92672">&amp;lt;=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>:
max_sum_with,max_with_start,max_with_end &lt;span style="color:#f92672">=&lt;/span> ele,i,i
&lt;span style="color:#66d9ef">else&lt;/span>:
max_sum_with,max_with_start,max_with_end &lt;span style="color:#f92672">=&lt;/span> max_sum_with&lt;span style="color:#f92672">+&lt;/span>ele,max_with_start,i
&lt;span style="color:#66d9ef">if&lt;/span> max_sum&lt;span style="color:#f92672">&amp;lt;&lt;/span>max_sum_with:
max_sum,max_start,max_end &lt;span style="color:#f92672">=&lt;/span> max_sum_with,max_with_start,max_with_end
&lt;span style="color:#66d9ef">return&lt;/span> max_sum,max_start,max_end
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="diameter-of-a-binary-tree">Diameter of a Binary Tree&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">tree_diameter&lt;/span>(root):
&lt;span style="color:#66d9ef">if&lt;/span> root &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0&lt;/span>
left_height,left_max_diameter,left_diameter_with_root &lt;span style="color:#f92672">=&lt;/span> tree_diameter(root&lt;span style="color:#f92672">.&lt;/span>left)
right_height,right_max_diameter,right_diameter_with_root &lt;span style="color:#f92672">=&lt;/span> tree_diameter(root&lt;span style="color:#f92672">.&lt;/span>right)
diameter_with_root &lt;span style="color:#f92672">=&lt;/span> left_height&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>right_height
max_diameter &lt;span style="color:#f92672">=&lt;/span> max(l_largest,r_largest,t)
height &lt;span style="color:#f92672">=&lt;/span> max(left_height,right_height)&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> height,max_diameter,diameter_with_root
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can observe a common structure in both of these algorithm. &lt;em>with and max&lt;/em> .&lt;/p>
&lt;p>While the computations is underway, both of them considers all the index/node in a particular order. For Kadane&amp;rsquo;s, the indices are examined one after the other in a linear order while tree diameter computation does an inorder traversal of the tree.&lt;/p>
&lt;p>While the algorithm is examining each elements, it always seems to compute 2 solutions. One where the solution must include the element. The &amp;ldquo;with&amp;rdquo; solution. The other solution is the most optimum answer over all the elements seen so far. The &amp;ldquo;max&amp;rdquo; solution.&lt;/p>
&lt;p>The max solution is then updated if the &lt;em>with&lt;/em> solution turns out to be a better solution.&lt;/p>
&lt;p>I keep stumbling across this structure from time to time. These are just 2 examples. Have you seen this structure elsewhere? Let me know.&lt;/p></description></item></channel></rss>