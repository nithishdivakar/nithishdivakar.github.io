<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Greedy on DAXPY</title><link>https://daxpy.xyz/tags/greedy/</link><description>Recent content in Greedy on DAXPY</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 01 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://daxpy.xyz/tags/greedy/index.xml" rel="self" type="application/rss+xml"/><item><title>Best Time to Buy and Sell Stock</title><link>https://daxpy.xyz/notes_collection/lc_notes/14b/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/notes_collection/lc_notes/14b/</guid><description>&lt;h2 id="best-time-to-buy-and-sell-stock-lc121"&gt;Best Time to Buy and Sell Stock [LC#121]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given an array prices where &lt;code&gt;prices[i]&lt;/code&gt; is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.&lt;/p&gt;</description></item><item><title>Best Time to Buy and Sell Stock II</title><link>https://daxpy.xyz/notes_collection/lc_notes/14b01/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/notes_collection/lc_notes/14b01/</guid><description>&lt;h2 id="best-time-to-buy-and-sell-stock-ii-lc122"&gt;Best Time to Buy and Sell Stock II [LC#122]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.&lt;/p&gt;</description></item><item><title>Gas Station</title><link>https://daxpy.xyz/notes_collection/lc_notes/84a01/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/notes_collection/lc_notes/84a01/</guid><description>&lt;h2 id="gas-station-lc134"&gt;Gas Station [LC#134]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;There are n gas stations along a circular route, where the amount of gas at the &lt;code&gt;station i&lt;/code&gt; is &lt;code&gt;gas[i]&lt;/code&gt;. You have a car with an unlimited gas tank and it costs &lt;code&gt;cost[i]&lt;/code&gt; of gas to travel from the station &lt;code&gt;i&lt;/code&gt; station to &lt;code&gt;(i + 1)&lt;/code&gt;. You begin the journey with an empty tank at one of the gas stations.&lt;/p&gt;
&lt;p&gt;Given two integer arrays gas and cost, return the starting gas station&amp;rsquo;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.&lt;/p&gt;</description></item><item><title>Jump Game</title><link>https://daxpy.xyz/notes_collection/lc_notes/84a03/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/notes_collection/lc_notes/84a03/</guid><description>&lt;h2 id="jump-game-lc55"&gt;Jump Game [LC#55]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="intuition"&gt;Intuition&lt;/h3&gt;
&lt;p&gt;There is a dp approach. But time complexity is $O(n^2)$ with linear storage. The greedy approach.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We keep track of the positions from which last index is reachable. In the begning its the last index itself.&lt;/li&gt;
&lt;li&gt;traverse the array in the reverse order. If we can reach on of the exisiting reachable position from current index, then the curent index is also in reachable.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="code"&gt;Code&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;jump_game&lt;/span&gt;(nums: List[int]) &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; bool:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; n &lt;span style="color:#f92672"&gt;=&lt;/span&gt; len(nums)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; left_limit &lt;span style="color:#f92672"&gt;=&lt;/span&gt; n &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; pos &lt;span style="color:#f92672"&gt;in&lt;/span&gt; range(n &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; pos &lt;span style="color:#f92672"&gt;+&lt;/span&gt; nums[pos] &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; left_limit:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; left_limit &lt;span style="color:#f92672"&gt;=&lt;/span&gt; pos
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; left_limit &lt;span style="color:#f92672"&gt;==&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="time-complexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;$T(n) = O(n)$&lt;/li&gt;
&lt;li&gt;$S(n) = O(1)$&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Jump Game II</title><link>https://daxpy.xyz/notes_collection/lc_notes/84a03a/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/notes_collection/lc_notes/84a03a/</guid><description>&lt;h2 id="jump-game-ii-lc45"&gt;Jump Game II [LC#45]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given a 0-indexed array of integers &lt;code&gt;nums&lt;/code&gt; of length n. You are initially positioned at &lt;code&gt;nums[0]&lt;/code&gt;. Each element &lt;code&gt;nums[i]&lt;/code&gt; represents the maximum length of a forward jump from index &lt;code&gt;i&lt;/code&gt;. Return the minimum number of jumps to reach the last position.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="intuition"&gt;Intuition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;There is a DP approach which takes $O(n^2)$ &lt;code&gt;steps[i] = 1+min(steps[j], 0&amp;lt;=j&amp;lt;i)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Say we are at a position left and max reachable range is till right.&lt;/p&gt;</description></item><item><title>Max Chunks To Make Sorted</title><link>https://daxpy.xyz/notes_collection/lc_notes/84a02/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/notes_collection/lc_notes/84a02/</guid><description>&lt;h2 id="max-chunks-to-make-sorted-lc769"&gt;Max Chunks To Make Sorted [LC#769]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1]. We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array. Return the largest number of chunks we can make to sort the array.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="intuition"&gt;Intuition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If we encounter a number k at position i, then $[i, k]$ should be in same chunk for the array to get sorted.&lt;/li&gt;
&lt;li&gt;So we traverse the array left to right and keep expanding the chunk&amp;rsquo;s right limit as we encounter new number.&lt;/li&gt;
&lt;li&gt;When we are a number and chunk&amp;rsquo;s limit cannot be expanded beyond the same position, we can start a new chunk.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="code"&gt;Code&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;maximum_chunks&lt;/span&gt;(arr: List[int]) &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; int:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; right_limit &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; count &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; i, num &lt;span style="color:#f92672"&gt;in&lt;/span&gt; enumerate(arr):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; right_limit &lt;span style="color:#f92672"&gt;=&lt;/span&gt; max(right_limit, num)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; i &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; right_limit:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; count &lt;span style="color:#f92672"&gt;+=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; count
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="time-complexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;$T(n) = O(n)$&lt;/li&gt;
&lt;li&gt;$S(n) = O(1)$&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Min Meeting Rooms</title><link>https://daxpy.xyz/notes_collection/lc_notes/50c/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/notes_collection/lc_notes/50c/</guid><description>&lt;h2 id="min-meeting-rooms-lc253"&gt;Min meeting rooms [LC#253]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Meeting Rooms II :
Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="intuition"&gt;Intuition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Sort all meetings by their start time&lt;/li&gt;
&lt;li&gt;Keep the ending times of currently occupied meeting rooms in the min heap&lt;/li&gt;
&lt;li&gt;If current start time is earlier than the min heap end time, we need a new room else we can pop the top and add a new room&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="code"&gt;Code&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;min_meeting_rooms&lt;/span&gt;(intervals: List[List[int]]) &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; int:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; intervals &lt;span style="color:#f92672"&gt;=&lt;/span&gt; sorted(intervals)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; heap &lt;span style="color:#f92672"&gt;=&lt;/span&gt; [intervals[&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;][&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;]] &lt;span style="color:#75715e"&gt;# first end time&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; meeting_rooms &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; start_time, end_time &lt;span style="color:#f92672"&gt;in&lt;/span&gt; intervals[&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;:]:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; start_time &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; heap[&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;]:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; heapq&lt;span style="color:#f92672"&gt;.&lt;/span&gt;heappop(heap)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; heapq&lt;span style="color:#f92672"&gt;.&lt;/span&gt;heappush(heap, end_time)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; meeting_rooms &lt;span style="color:#f92672"&gt;=&lt;/span&gt; max(meeting_rooms, len(heap))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; meeting_rooms
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="time-complexity"&gt;Time Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;$T(n) = O(n \log n + n \log n)$ sorting + n pops&lt;/li&gt;
&lt;li&gt;$S(n) = O(n)$&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Minimum Number of Arrows to Burst Balloons</title><link>https://daxpy.xyz/notes_collection/lc_notes/50e/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/notes_collection/lc_notes/50e/</guid><description>&lt;h2 id="minimum-number-of-arrows-to-burst-balloons-lc452"&gt;Minimum Number of Arrows to Burst Balloons [LC#452]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.&lt;/p&gt;
&lt;p&gt;Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &amp;lt;= x &amp;lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.&lt;/p&gt;</description></item></channel></rss>