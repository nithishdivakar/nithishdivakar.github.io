<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on DAXPY</title><link>https://daxpy.xyz/tags/algorithms/</link><description>Recent content in Algorithms on DAXPY</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 20 Oct 2023 05:52:32 +0530</lastBuildDate><atom:link href="https://daxpy.xyz/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Knapsack</title><link>https://daxpy.xyz/notes/knapsack/</link><pubDate>Fri, 20 Oct 2023 05:52:32 +0530</pubDate><guid>https://daxpy.xyz/notes/knapsack/</guid><description>&lt;h1 id="knapsack">Knapsack&lt;/h1>
&lt;p>Knapsack problems are probably the first introduction to many on problems where you are trying to optimize a dimension while constrained by another. Let&amp;rsquo;s look at it in depth.&lt;/p>
&lt;p>You are given a metaphorical knapsack which atmost can carry $W$ weight items. You are also given $n$ items, each with its own weight $w_i$ and value $v_i$. We are asked to select a few items from this set so that the total weight is atmost $W$ while maximising the total value.&lt;/p></description></item><item><title>Quick Select</title><link>https://daxpy.xyz/notes/quick-select/</link><pubDate>Mon, 14 Mar 2022 08:30:00 +0530</pubDate><guid>https://daxpy.xyz/notes/quick-select/</guid><description>&lt;h1 id="quick-select">Quick Select&lt;/h1>
&lt;p>The core technique in quick sort is partition procedure. The partition procedure partitions the array into 2 segments such that for a choosen pivot element, one segment has all element smaller or equal and the other has all element larger than pivot.&lt;/p>
&lt;p>The procedure itself has applications beyond quick sort like selecting the smallest $k$ elements if sorted order is not required.&lt;/p>
&lt;p>There are 2 main techniques to implement quick select.&lt;/p></description></item><item><title>Finding Median</title><link>https://daxpy.xyz/posts/finding-median/</link><pubDate>Tue, 01 Mar 2022 06:59:51 +0530</pubDate><guid>https://daxpy.xyz/posts/finding-median/</guid><description>&lt;h1 id="finding-median">Finding Median&lt;/h1>
&lt;p>&lt;em>Here is my &lt;a href="https://www.dictionary.com/e/slang/eli5/">ELI5&lt;/a> definition of a median.&lt;/em>&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;Median is the middle number when numbers are sorted&amp;rdquo;.&lt;/p>&lt;/blockquote>
&lt;p>There is only a single middle number when the size list is odd. But if the size is even, there are 2 middle numbers. Then we take an average of those 2 numbers to be the median.&lt;/p>
&lt;p>Median is useful when your data doesn&amp;rsquo;t behave. Medians are part of &amp;ldquo;robust statistics&amp;rdquo; because they are not affected by outliers. Both $[1,2,100]$ and $[1,2,3]$ have 2 as their median while their means differ widely. You can see why medians are not affected by noise.&lt;/p></description></item><item><title>Binary Search</title><link>https://daxpy.xyz/posts/binary-search-problems/</link><pubDate>Fri, 28 Jan 2022 06:59:51 +0530</pubDate><guid>https://daxpy.xyz/posts/binary-search-problems/</guid><description>&lt;h1 id="binary-search">Binary Search&lt;/h1>
&lt;p>Binary search is more than just a search algorithm for sorted arrays. It&amp;rsquo;s an algorithm which keeps showing up as optimal solutions in unlikely places. This note is a very limited exploration of what binary search can do.&lt;/p>
&lt;p>Let&amp;rsquo;s begin by talking about vanilla binary search.&lt;/p>
&lt;h2 id="binary-search-1">Binary Search&lt;/h2>
&lt;p>We are given a sorted array of numbers and a target. Binary search is the most optimal way of finding position of target in the array if present.&lt;/p></description></item></channel></rss>