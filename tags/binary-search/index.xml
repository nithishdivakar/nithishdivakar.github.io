<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary Search on DAXPY</title><link>https://daxpy.xyz/tags/binary-search/</link><description>Recent content in Binary Search on DAXPY</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 01 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://daxpy.xyz/tags/binary-search/index.xml" rel="self" type="application/rss+xml"/><item><title>Binary Search in Sorted Array</title><link>https://daxpy.xyz/collections/lc_notes/75a01/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/collections/lc_notes/75a01/</guid><description>&lt;h2 id="binary-search-in-a-sorted-array"&gt;Binary search in a sorted array&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt; [ &amp;lt; ][ = ][ &amp;gt; ] 
&lt;/code&gt;&lt;/pre&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;binary_search_array&lt;/span&gt;(arr: List[int], target: int) &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; int:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; left, right &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, len(arr) &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; left &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; right:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; mid &lt;span style="color:#f92672"&gt;=&lt;/span&gt; left &lt;span style="color:#f92672"&gt;+&lt;/span&gt; (right &lt;span style="color:#f92672"&gt;-&lt;/span&gt; left) &lt;span style="color:#f92672"&gt;//&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; arr[mid] &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; target:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; right &lt;span style="color:#f92672"&gt;=&lt;/span&gt; mid
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; left &lt;span style="color:#f92672"&gt;=&lt;/span&gt; mid &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; left &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; arr[left] &lt;span style="color:#f92672"&gt;==&lt;/span&gt; target &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>Find Minimum in Rotated Sorted Array</title><link>https://daxpy.xyz/collections/lc_notes/75a03/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/collections/lc_notes/75a03/</guid><description>&lt;h2 id="find-minimum-in-rotated-sorted-array-lc153"&gt;Find Minimum in Rotated Sorted Array [LC#153]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[4,5,6,7,0,1,2] if it was rotated 4 times.&lt;/li&gt;
&lt;li&gt;[0,1,2,4,5,6,7] if it was rotated 7 times.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notice that rotating an array &lt;code&gt;[a[0], a[1], a[2], ..., a[n-1]]&lt;/code&gt; 1 time results in the array &lt;code&gt;[a[n-1], a[0], a[1], a[2], ..., a[n-2]]&lt;/code&gt;. Given the sorted rotated array nums of unique elements, return the minimum element of this array.&lt;/p&gt;</description></item><item><title>First and Last Position in a Sorted Array</title><link>https://daxpy.xyz/collections/lc_notes/75a02/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/collections/lc_notes/75a02/</guid><description>&lt;h2 id="find-first-and-last-position-of-element-in-sorted-array-lc34"&gt;Find First and Last Position of Element in Sorted Array [LC#34]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="code"&gt;Code&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;searchRange&lt;/span&gt;(nums: List[int], target: int) &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; Tuple[int, int]:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;binary_search&lt;/span&gt;(value):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; left, right &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, len(nums) &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; left &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; right:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; mid &lt;span style="color:#f92672"&gt;=&lt;/span&gt; left &lt;span style="color:#f92672"&gt;+&lt;/span&gt; (right &lt;span style="color:#f92672"&gt;-&lt;/span&gt; left) &lt;span style="color:#f92672"&gt;//&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; nums[mid] &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; value:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; right &lt;span style="color:#f92672"&gt;=&lt;/span&gt; mid
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; left &lt;span style="color:#f92672"&gt;=&lt;/span&gt; mid &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; left
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; nums&lt;span style="color:#f92672"&gt;.&lt;/span&gt;append(math&lt;span style="color:#f92672"&gt;.&lt;/span&gt;inf) &lt;span style="color:#75715e"&gt;# to handle edge cases&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; pos_beg &lt;span style="color:#f92672"&gt;=&lt;/span&gt; binary_search(target)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; nums[pos_beg] &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; target:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; (&lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; pos_end &lt;span style="color:#f92672"&gt;=&lt;/span&gt; binary_search(target &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; (pos_beg, pos_end &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="time-complexity"&gt;Time Complexity&lt;/h3&gt;
&lt;p&gt;$T(n) = O(\log n)$&lt;/p&gt;</description></item><item><title>Minimum Limit of Balls in a Bag</title><link>https://daxpy.xyz/collections/lc_notes/75b/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/collections/lc_notes/75b/</guid><description>&lt;h2 id="minimum-limit-of-balls-in-a-bag-lc1760"&gt;Minimum Limit of Balls in a Bag [LC#1760]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given an integer array nums where the ith bag contains &lt;code&gt;nums[i]&lt;/code&gt; balls. You are also given an integer &lt;code&gt;max_operations&lt;/code&gt;. You can perform the following operation at most &lt;code&gt;max_operations&lt;/code&gt; times:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Take any bag of balls and divide it into two new bags with a positive number of balls. For example, a bag of 5 balls can become two new bags of 1 and 4 balls, or two new bags of 2 and 3 balls.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations. Return the minimum possible penalty after performing the operations.&lt;/p&gt;</description></item><item><title>Split Array Largest Sum</title><link>https://daxpy.xyz/collections/lc_notes/75d/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/collections/lc_notes/75d/</guid><description>&lt;h2 id="split-array-largest-sum-lc412"&gt;Split Array Largest Sum [LC#412]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum of the split. A subarray is a contiguous part of the array.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="intuition"&gt;Intuition&lt;/h3&gt;
&lt;p&gt;Binary search on the range of possible values.&lt;/p&gt;
&lt;h3 id="code"&gt;Code&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;splita_array_largest_sum&lt;/span&gt;(nums: List[int], k: int) &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; int:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; left, right &lt;span style="color:#f92672"&gt;=&lt;/span&gt; max(nums), sum(nums)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;valid&lt;/span&gt;(th):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; num_partitions &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; sum_partition &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; num &lt;span style="color:#f92672"&gt;in&lt;/span&gt; nums:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; sum_partition &lt;span style="color:#f92672"&gt;+&lt;/span&gt; num &lt;span style="color:#f92672"&gt;&amp;lt;=&lt;/span&gt; th:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; sum_partition &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; num
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; sum_partition &lt;span style="color:#f92672"&gt;=&lt;/span&gt; num
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; num_partitions &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; num_partitions &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; k:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; left &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; right:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; mid &lt;span style="color:#f92672"&gt;=&lt;/span&gt; left &lt;span style="color:#f92672"&gt;+&lt;/span&gt; (right &lt;span style="color:#f92672"&gt;-&lt;/span&gt; left) &lt;span style="color:#f92672"&gt;//&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; valid(mid):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; right &lt;span style="color:#f92672"&gt;=&lt;/span&gt; mid
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; left &lt;span style="color:#f92672"&gt;=&lt;/span&gt; mid &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; right
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="time-complexity"&gt;Time Complexity&lt;/h2&gt;
&lt;p&gt;The search take &lt;code&gt;log(range)&lt;/code&gt; steps. The range is of size $2^b$ if $b$ is max number of bits representing the numbers in the list &lt;code&gt;nums&lt;/code&gt;. Hence number of search steps is upperbounded by $\log (2^b) = b$. Each step take $O(n)$ to evaluate the validity condition. So time complexity $T(n) = O(b \ast n)$. If we consider $b$ as a constant then time complexity is $O(n)$&lt;/p&gt;</description></item><item><title>Swim in Rising Water</title><link>https://daxpy.xyz/collections/lc_notes/75e/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/collections/lc_notes/75e/</guid><description>&lt;h2 id="swim-in-rising-water-lc778"&gt;Swim in Rising Water [LC#778]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given an &lt;code&gt;n x n&lt;/code&gt; integer matrix grid where each value &lt;code&gt;grid[i][j]&lt;/code&gt; represents the elevation at that point &lt;code&gt;(i, j)&lt;/code&gt;. The rain starts to fall. At time &lt;code&gt;t&lt;/code&gt;, the depth of the water everywhere is &lt;code&gt;t&lt;/code&gt;. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.&lt;/p&gt;</description></item><item><title>Zero Array Transformation II</title><link>https://daxpy.xyz/collections/lc_notes/50d02/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://daxpy.xyz/collections/lc_notes/50d02/</guid><description>&lt;h2 id="zero-array-transformation-ii-lc3356"&gt;Zero Array Transformation II [LC#3356]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given an integer array nums of length &lt;code&gt;n&lt;/code&gt; and a 2D array queries where &lt;code&gt;queries[i] = [l_i, r_i, val_i]&lt;/code&gt;. Each &lt;code&gt;queries[i]&lt;/code&gt; represents the following action on nums:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Decrement the value at each index in the range &lt;code&gt;[l_i, r_i]&lt;/code&gt; in nums by at most &lt;code&gt;val_i&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The amount by which each value is decremented can be chosen independently for each index.
A Zero Array is an array with all its elements equal to 0. Return the minimum possible non-negative value of &lt;code&gt;k&lt;/code&gt;, such that after processing the first &lt;code&gt;k&lt;/code&gt; queries in sequence, nums becomes a Zero Array. If no such &lt;code&gt;k&lt;/code&gt; exists, return &lt;code&gt;-1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id="intuition"&gt;Intuition&lt;/h3&gt;
&lt;p&gt;Line sweep and binary search on min queries required.&lt;/p&gt;</description></item></channel></rss>